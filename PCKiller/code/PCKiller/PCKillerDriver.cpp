#include <ntddk.h>
#include <wdm.h>
#pragma warning(disable : 4996)

#define IOCTL_SET_SHUTDOWN_TIMER CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CANCEL_SHUTDOWN_TIMER CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_QUERY_REMAINING_TIME CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_BUFFERED, FILE_ANY_ACCESS)

PDEVICE_OBJECT g_DeviceObject = NULL;
UNICODE_STRING g_usDeviceName, g_usSymlinkName;
KTIMER g_ShutdownTimer;
KDPC g_ShutdownDpc;
LARGE_INTEGER g_TimeInterval;
BOOLEAN g_TimerSet = FALSE;
// Calc remaining
LARGE_INTEGER whenTimerWasSet;
LONG shutdownDelay;

typedef enum _SHUTDOWN_ACTION
{
    ShutdownNoReboot,
    ShutdownReboot,
    ShutdownPowerOff,
    ShutdownRebootForRecovery // since WIN11
} SHUTDOWN_ACTION;

typedef
NTSTATUS
(*NtShutdownSystem)(
    _In_ SHUTDOWN_ACTION Action
);

NtShutdownSystem NtShutDownSystem = NULL;


VOID NTAPI MyShutdownSystem(PVOID) { 
    DbgPrint("MyShutdownSystem is called!\n");
    NtShutDownSystem(ShutdownNoReboot); 
}


VOID TimerDpcRoutine(KDPC* Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2) {
    // Perform system shutdown
    //ZwShutdownSystem(ShutdownPowerOff);
    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(DeferredContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);
    DbgPrint("In DPC!\n");
    UNICODE_STRING functionName = { 0 };
    RtlInitUnicodeString(&functionName, L"NtShutdownSystem");
    NtShutDownSystem = (NtShutdownSystem)MmGetSystemRoutineAddress(&functionName);

    if (NtShutDownSystem != NULL) {
        DbgPrint("We got NtShutDownSystem function ptr!!!\n");
        //NtShutDownSystem(ShutdownNoReboot);

        PWORK_QUEUE_ITEM pWorkItem =
            (PWORK_QUEUE_ITEM)ExAllocatePool(NonPagedPool, sizeof(WORK_QUEUE_ITEM));
        if (pWorkItem != NULL) {
            DbgPrint("Allocated work queue item!!!\n");
            ExInitializeWorkItem(pWorkItem, &MyShutdownSystem, NULL);
            DbgPrint("ExInitializeWorkItem!!!\n");
            ExQueueWorkItem(pWorkItem, DelayedWorkQueue);
            DbgPrint("ExQueueWorkItem!!!\n");
        }
    }
}


VOID UnloadDriver(PDRIVER_OBJECT DriverObject) {
    if (g_TimerSet) {
        KeCancelTimer(&g_ShutdownTimer);
    }
    IoDeleteSymbolicLink(&g_usSymlinkName);
    IoDeleteDevice(DriverObject->DeviceObject);
    DbgPrint("Driver Unloading\n");
}

NTSTATUS CreateCloseRoutine(PDEVICE_OBJECT DeviceObject, PIRP Irp) {
    UNREFERENCED_PARAMETER(DeviceObject);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

NTSTATUS DeviceControlRoutine(PDEVICE_OBJECT DeviceObject, PIRP Irp) {
    UNREFERENCED_PARAMETER(DeviceObject);

    PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_INVALID_DEVICE_REQUEST;
    ULONG_PTR information = 0;

    switch (stack->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_SET_SHUTDOWN_TIMER:
        if (g_TimerSet) {
            KeCancelTimer(&g_ShutdownTimer);
            DbgPrint("Canceled timer - setting new one.\n");
        }
        shutdownDelay = (*(PLONG)Irp->AssociatedIrp.SystemBuffer);
        g_TimeInterval.QuadPart = -10000000LL * shutdownDelay; // 100-nanosecond intervals
        KeSetTimer(&g_ShutdownTimer, g_TimeInterval, &g_ShutdownDpc);
        KeQuerySystemTime(&whenTimerWasSet);
        DbgPrint("Setted up timer!\n");
        g_TimerSet = TRUE;
        status = STATUS_SUCCESS;
        break;
    case IOCTL_CANCEL_SHUTDOWN_TIMER:
        if (g_TimerSet) {
            KeCancelTimer(&g_ShutdownTimer);
            g_TimerSet = FALSE;
            DbgPrint("Canceled timer!\n");
        }
        status = STATUS_SUCCESS;
        break;
    case IOCTL_QUERY_REMAINING_TIME:
        if (g_TimerSet) {
            LARGE_INTEGER currentTime;
            KeQuerySystemTime(&currentTime);
            //LONG remaining = (LONG)(g_ShutdownTimer.DueTime.QuadPart - (currentTime.QuadPart / 10000000LL));
            // I really don't know what's going on here... The timer is straight up lying to me on returned time - but the timer goes off at the exact time..
            // It even shows Remaining time: 11 seconds after 2-3 seconds from setting up the timer.
            // However when remaining time = 0 this is precisly the true 0. LOL I really don't know what it this black magic....
            LONG remaining = (LONG)(shutdownDelay + ((whenTimerWasSet.QuadPart - currentTime.QuadPart) / 10000000LL));
            *(PLONG)Irp->AssociatedIrp.SystemBuffer = remaining;
            DbgPrint("Remaining time: %ld seconds\n", remaining);
            information = sizeof(LONG);
        }
        status = STATUS_SUCCESS;
        break;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = information;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) {
    UNREFERENCED_PARAMETER(RegistryPath);

    NTSTATUS status;

    RtlInitUnicodeString(&g_usDeviceName, L"\\Device\\PCKiller");
    RtlInitUnicodeString(&g_usSymlinkName, L"\\DosDevices\\PCKiller");

    status = IoCreateDevice(DriverObject, 0, &g_usDeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, &g_DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = IoCreateSymbolicLink(&g_usSymlinkName, &g_usDeviceName);
    if (!NT_SUCCESS(status)) {
        IoDeleteDevice(g_DeviceObject);
        return status;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE] = CreateCloseRoutine;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = CreateCloseRoutine;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DeviceControlRoutine;
    DriverObject->DriverUnload = UnloadDriver;

    KeInitializeTimer(&g_ShutdownTimer);
    KeInitializeDpc(&g_ShutdownDpc, TimerDpcRoutine, NULL);

    return STATUS_SUCCESS;
}