#include <fltKernel.h>
#include <ntddk.h>
#include <wdm.h>
#include <ntifs.h>
#include <wchar.h>

// Disable warining to Depricated function ExAllocatePoolWithTag
#pragma warning(disable : 4996)
// Disable warning to mmmm... idk there was some problem before, it's gone now lol.
//#pragma warning(disable : 4244)

// Our IOCTL to communicate with userspace program
#define IOCTL_BLACK_LIST_FILE  CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_BLACK_LIST_PROCESS CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_WHITE_LIST_PROCESS CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INIT_AV CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_TERMINATE_PROCESS CTL_CODE(FILE_DEVICE_UNKNOWN, 0x804, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DUMP_PROCESS_MEMORY CTL_CODE(FILE_DEVICE_UNKNOWN, 0x805, METHOD_BUFFERED, FILE_ANY_ACCESS)

// Some Consts
#define MAX_FILENAME_LENGTH 256
#define PROCESS_TERMINATE (0x0001) 
#define PROCESS_VM_READ (0x0010)

// Globals
PFLT_FILTER g_FilterHandle;
PDEVICE_OBJECT g_DeviceObject = NULL;
UNICODE_STRING g_usDeviceName, g_usSymlinkName;
WCHAR g_blockedFilename[MAX_FILENAME_LENGTH] = L"";
WCHAR g_blacklistedProcess[MAX_FILENAME_LENGTH] = L"";
WCHAR g_whitelistedProcess[MAX_FILENAME_LENGTH] = L"";

// Define a struct to receive dump information from user mode
typedef struct _DUMP_INFO {
    ULONG pid;
    ULONG size;
    WCHAR dumpFilePath[260];  // Maximum path length
} DUMP_INFO, * PDUMP_INFO;

//Undocumented GetProcessImageFileName
typedef PCHAR(*GET_PROCESS_IMAGE_NAME) (PEPROCESS Process);
GET_PROCESS_IMAGE_NAME gGetProcessImageFileName = NULL;

//Undocumented PsGetProcessSectionBaseAddress
typedef PVOID
(*PsGetProcessSectionBaseAddress) (
    __in PEPROCESS Process
);
PsGetProcessSectionBaseAddress gPsGetProcessSectionBaseAddress = NULL;


// Undocumented NtReadVirtualMemory
// Could be found with memory scanning or from KeServiceDescriptorTable (but not with MmGetSystemRoutineAddress)
/*
typedef NTSTATUS
(*ZwReadVirtualMemory)(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _Out_writes_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesRead
);
ZwReadVirtualMemory gZwReadVirtualMemory = NULL;
*/

//Undocumented MmCopyVirtulMemory
typedef NTSTATUS (*MmCopyVirtualMemory) (
    PEPROCESS SourceProcess,
    PVOID SourceAddress,
    PEPROCESS TargetProcess,
    PVOID TargetAddress,
    SIZE_T BufferSize,
    KPROCESSOR_MODE PreviousMode,
    PSIZE_T ReturnSize
);
MmCopyVirtualMemory gMmCopyVirtualMemory = NULL;


// Minifilter stuff
NTSTATUS UnloadFilter(FLT_FILTER_UNLOAD_FLAGS Flags);
VOID UnloadDriver(PDRIVER_OBJECT DriverObject);
FLT_PREOP_CALLBACK_STATUS PreOperationCallback(
    PFLT_CALLBACK_DATA Data,
    PCFLT_RELATED_OBJECTS FltObjects,
    PVOID* CompletionContext);
NTSTATUS CreateCloseRoutine(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS DeviceControlRoutine(PDEVICE_OBJECT DeviceObject, PIRP Irp);

const FLT_OPERATION_REGISTRATION Callbacks[] = {
    { IRP_MJ_CREATE,
      0,
      PreOperationCallback,
      NULL },
    { IRP_MJ_OPERATION_END }
};

const FLT_REGISTRATION FilterRegistration = {
    sizeof(FLT_REGISTRATION),         // Size
    FLT_REGISTRATION_VERSION,         // Version
    0,                                // Flags
    NULL,                             // Context
    Callbacks,                        // Operation callbacks
    UnloadFilter,                     // FilterUnloadCallback
    NULL,                             // InstanceSetupCallback
    NULL,                             // InstanceQueryTeardownCallback
    NULL,                             // InstanceTeardownStartCallback
    NULL                              // InstanceTeardownCompleteCallback
};

// Found this in: https://github.com/Zer0Mem0ry/KernelReadWriteMemory/blob/master/ReadWrite.c
NTSTATUS KeReadVirtualMemory(PEPROCESS Process, PVOID SourceAddress, PVOID TargetAddress, SIZE_T Size)
{
    SIZE_T Bytes;
    NTSTATUS success;
    success = gMmCopyVirtualMemory(Process, SourceAddress, PsGetCurrentProcess(), TargetAddress, Size, KernelMode, &Bytes);
    if (NT_SUCCESS(success))
        return STATUS_SUCCESS;
    else
        return STATUS_ACCESS_DENIED;
}

// Custom terminate process by the PID
NTSTATUS TerminateProcessByPid(HANDLE Pid) {
    PEPROCESS Process;
    HANDLE ProcessHandle;
    NTSTATUS status;

    // Get the PEPROCESS structure of the target PID
    status = PsLookupProcessByProcessId(Pid, &Process);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    // Get a handle to the process with terminate access
    status = ObOpenObjectByPointer(
        Process,
        OBJ_KERNEL_HANDLE,
        NULL,
        PROCESS_TERMINATE,
        *PsProcessType,
        KernelMode,
        &ProcessHandle
    );

    if (!NT_SUCCESS(status)) {
        ObDereferenceObject(Process);
        return status;
    }

    DbgPrint("Calling ZwTerminateProcess on PID: %lu\n", (ULONG)(ULONG_PTR)Pid);
    // Now terminate the process using the handle
    status = ZwTerminateProcess(ProcessHandle, 5);

    DbgPrint("Cleanup ZwTerminateProcess\n");
    // Close the handle and dereference the object
    ZwClose(ProcessHandle);
    ObDereferenceObject(Process);

    return status;
}

// Callback called when a new process is created
VOID CreateProcessNotifyRoutine(HANDLE ParentId, HANDLE ProcessId, BOOLEAN Create) {
    UNREFERENCED_PARAMETER(ParentId);

    if (!Create) return;

    PEPROCESS Process;
    if (PsLookupProcessByProcessId(ProcessId, &Process) == STATUS_SUCCESS) {

        // Get Process image name
        //WCHAR processName[MAX_FILENAME_LENGTH];
        PCHAR pImageName = gGetProcessImageFileName(Process);

        // Convert ANSI string to Unicode
        WCHAR wImageName[MAX_FILENAME_LENGTH];
        swprintf(wImageName, L"%S", pImageName); // L"%S" converts ANSI to WCHAR

        DbgPrint("Checking process: %S with PID: %lu\n", wImageName, (ULONG)(ULONG_PTR)ProcessId);

        BOOLEAN block = FALSE;
        if (wcslen(g_whitelistedProcess) > 0) {
            //Avoid locking yourself out of control
            if (_wcsicmp(wImageName, L"SugiotAVConsol") != 0) {
                // If there's a whitelisted process, block all except it
                block = (_wcsicmp(wImageName, g_whitelistedProcess) != 0);
            }
            else {
                DbgPrint("It's SugiotAVConsole! Can't block or we will be locked out :(\n");
            }

        }
        else if (wcslen(g_blacklistedProcess) > 0) {
            // If there's a blacklisted process, block it
            block = (_wcsicmp(wImageName, g_blacklistedProcess) == 0);
        }

        if (block) {
            // Terminate the process or deny creation
            DbgPrint("Terminating process: %S with PID: %lu\n", wImageName, (ULONG)(ULONG_PTR)ProcessId);
            TerminateProcessByPid(ProcessId);
        }
    }
}

// Minifilter callback, called on each file system access
FLT_PREOP_CALLBACK_STATUS PreOperationCallback(
    PFLT_CALLBACK_DATA Data,
    PCFLT_RELATED_OBJECTS FltObjects,
    PVOID* CompletionContext) {
    UNREFERENCED_PARAMETER(CompletionContext);
    UNREFERENCED_PARAMETER(FltObjects);

    PFLT_FILE_NAME_INFORMATION FileNameInfo;
    NTSTATUS status;
    WCHAR Name[MAX_FILENAME_LENGTH] = { 0 };

    if (wcslen(g_blockedFilename) > 0) {

        status = FltGetFileNameInformation(Data, FLT_FILE_NAME_NORMALIZED | FLT_FILE_NAME_QUERY_DEFAULT, &FileNameInfo);

        if (NT_SUCCESS(status)) {
            status = FltParseFileNameInformation(FileNameInfo);

            if (NT_SUCCESS(status)) {
                if (FileNameInfo->Name.MaximumLength < MAX_FILENAME_LENGTH) {
                    RtlCopyMemory(Name, FileNameInfo->Name.Buffer, FileNameInfo->Name.MaximumLength);
                    _wcsupr(Name);
                    if (wcsstr(FileNameInfo->Name.Buffer, g_blockedFilename) != NULL) {
                        // Block filename
                        DbgPrint("File blocked: %S\n", Name);
                        Data->IoStatus.Status = STATUS_ACCESS_DENIED;
                        Data->IoStatus.Information = 0;

                        FltReleaseFileNameInformation(FileNameInfo);

                        return FLT_PREOP_COMPLETE;
                    }
                }
            }

            FltReleaseFileNameInformation(FileNameInfo);
        }
    }

    return FLT_PREOP_SUCCESS_NO_CALLBACK;
}

// Basic create / close driver functionality to support IOCTL communication
NTSTATUS CreateCloseRoutine(PDEVICE_OBJECT DeviceObject, PIRP Irp) {
    DbgPrint("CreateCloseRoutine called\n");
    UNREFERENCED_PARAMETER(DeviceObject);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

// Dumps requested process memory by 'dumpInfo' from the process baseaddress
NTSTATUS DumpProcessMemory(PDUMP_INFO dumpInfo) {
    PEPROCESS Process;
    HANDLE ProcessHandle;
    NTSTATUS status = PsLookupProcessByProcessId((HANDLE)(ULONG_PTR)dumpInfo->pid, &Process);
    if (!NT_SUCCESS(status)) return status;
    DbgPrint("[DumpProcessMemory]: Found Process\n");

    status = ObOpenObjectByPointer(Process, OBJ_KERNEL_HANDLE, NULL, PROCESS_VM_READ, *PsProcessType, KernelMode, &ProcessHandle);
    if (!NT_SUCCESS(status)) {
        ObDereferenceObject(Process);
        return status;
    }
    DbgPrint("[DumpProcessMemory]: Got HANDLE to Process\n");


    // Allocate buffer to hold the memory dump
    PVOID buffer = ExAllocatePoolWithTag(NonPagedPool, dumpInfo->size, 'dmp1');
    if (buffer == NULL) {
        ZwClose(ProcessHandle);
        ObDereferenceObject(Process);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    DbgPrint("[DumpProcessMemory]: Allocated memory for dump\n");

    // Dumping memory
    // Solution to dumping process memory found in: https://github.com/Zer0Mem0ry/KernelReadWriteMemory/blob/master/ReadWrite.c
    // Here below I tried to use ZwReadVirtualMemory - However it does not exist, only NtReadVirtualMemory. This one could be found with KeServiceDescriptorTable or memory scanning:
    // as explained in: https://stackoverflow.com/a/50957319
    //SIZE_T bytesRead;
    //status = gZwReadVirtualMemory(ProcessHandle, (PVOID)gPsGetProcessSectionBaseAddress(Process), buffer, dumpInfo->size, &bytesRead);
    status = KeReadVirtualMemory(Process, (PVOID)gPsGetProcessSectionBaseAddress(Process), buffer, dumpInfo->size);
    if (!NT_SUCCESS(status)) {
        ExFreePoolWithTag(buffer, 'dmp1');
        ZwClose(ProcessHandle);
        ObDereferenceObject(Process);
        return status;
    }
    DbgPrint("[DumpProcessMemory]: Read memory\n");

    // Set up file I/O
    // Solution to writing to file is found in: https://stackoverflow.com/a/56958273
    UNICODE_STRING filePath;
    RtlInitUnicodeString(&filePath, dumpInfo->dumpFilePath);
    HANDLE hFile;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;

    InitializeObjectAttributes(&ObjectAttributes, &filePath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

    status = ZwCreateFile(&hFile, FILE_GENERIC_WRITE, &ObjectAttributes, &IoStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);
    if (!NT_SUCCESS(status)) {
        DbgPrint("[DumpProcessMemory]: Creating file error");
        ExFreePoolWithTag(buffer, 'dmp1');
        ZwClose(ProcessHandle);
        ObDereferenceObject(Process);
        return status;
    }
    DbgPrint("[DumpProcessMemory]: Created file for dump\n");

    //status = ZwWriteFile(hFile, NULL, NULL, NULL, &IoStatusBlock, buffer, bytesRead, NULL, NULL);
    status = ZwWriteFile(hFile, NULL, NULL, NULL, &IoStatusBlock, buffer, dumpInfo->size, NULL, NULL);
    if (!NT_SUCCESS(status)) {
        DbgPrint("[DumpProcessMemory]: Writing file error");
    }
    DbgPrint("[DumpProcessMemory]: Written dump to file\n");

    ZwClose(hFile);
    ExFreePoolWithTag(buffer, 'dmp1');
    ZwClose(ProcessHandle);
    ObDereferenceObject(Process);
    return status;
}

// IOCTL control (IRP) communication with userspace program
NTSTATUS DeviceControlRoutine(PDEVICE_OBJECT DeviceObject, PIRP Irp) {
    UNREFERENCED_PARAMETER(DeviceObject);

    PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_INVALID_DEVICE_REQUEST;
    ULONG_PTR information = 0;

    switch (stack->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_BLACK_LIST_FILE:
        DbgPrint("IOCTL_BLACK_LIST_FILE called.\n");
        if (stack->Parameters.DeviceIoControl.InputBufferLength < MAX_FILENAME_LENGTH * sizeof(WCHAR)) {
            RtlCopyMemory(g_blockedFilename, Irp->AssociatedIrp.SystemBuffer, stack->Parameters.DeviceIoControl.InputBufferLength);
            g_blockedFilename[stack->Parameters.DeviceIoControl.InputBufferLength / sizeof(WCHAR)] = L'\0';  // Null-terminate
            DbgPrint("Blocking file set to: %ws\n", g_blockedFilename);
            status = STATUS_SUCCESS;
        }
        else {
            status = STATUS_BUFFER_OVERFLOW;
        }
        break;
    case IOCTL_BLACK_LIST_PROCESS:
        if (stack->Parameters.DeviceIoControl.InputBufferLength < MAX_FILENAME_LENGTH * sizeof(WCHAR)) {
            RtlZeroMemory(g_blacklistedProcess, sizeof(g_blacklistedProcess));
            RtlCopyMemory(g_blacklistedProcess, Irp->AssociatedIrp.SystemBuffer, stack->Parameters.DeviceIoControl.InputBufferLength);
            DbgPrint("Blacklisted process: %ws\n", g_blacklistedProcess);
            status = STATUS_SUCCESS;
        }
        break;
    case IOCTL_WHITE_LIST_PROCESS:
        if (stack->Parameters.DeviceIoControl.InputBufferLength < MAX_FILENAME_LENGTH * sizeof(WCHAR)) {
            RtlZeroMemory(g_whitelistedProcess, sizeof(g_whitelistedProcess));
            RtlCopyMemory(g_whitelistedProcess, Irp->AssociatedIrp.SystemBuffer, stack->Parameters.DeviceIoControl.InputBufferLength);
            DbgPrint("Whitelisted process: %ws\n", g_whitelistedProcess);
            status = STATUS_SUCCESS;
        }
        break;
    case IOCTL_INIT_AV:
        // Reset all settings
        RtlZeroMemory(g_blockedFilename, sizeof(g_blockedFilename));
        RtlZeroMemory(g_blacklistedProcess, sizeof(g_blacklistedProcess));
        RtlZeroMemory(g_whitelistedProcess, sizeof(g_whitelistedProcess));
        status = STATUS_SUCCESS;
        break;
    case IOCTL_TERMINATE_PROCESS:
        if (stack->Parameters.DeviceIoControl.InputBufferLength == sizeof(ULONG)) {
            ULONG pid;
            RtlCopyMemory(&pid, Irp->AssociatedIrp.SystemBuffer, sizeof(ULONG));
            status = TerminateProcessByPid((HANDLE)(ULONG_PTR)pid);
        }
        else {
            status = STATUS_INVALID_PARAMETER;
        }
        break;
    case IOCTL_DUMP_PROCESS_MEMORY:
        if (stack->Parameters.DeviceIoControl.InputBufferLength == sizeof(DUMP_INFO)) {
            PDUMP_INFO dumpInfo = (PDUMP_INFO)Irp->AssociatedIrp.SystemBuffer;
            status = DumpProcessMemory(dumpInfo);
        }
        else {
            status = STATUS_INVALID_PARAMETER;
        }
        break;
    default:
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = information;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

// Unload filter -> registered in the minifilter, but never called lol
NTSTATUS UnloadFilter(FLT_FILTER_UNLOAD_FLAGS Flags) {
    DbgPrint("UnloadFilter\n");
    UNREFERENCED_PARAMETER(Flags);
    FltUnregisterFilter(g_FilterHandle);
    PsSetCreateProcessNotifyRoutine(CreateProcessNotifyRoutine, TRUE);
    return STATUS_SUCCESS;
}

// Unload Driver - called when driver is unloaded from kernel space
VOID UnloadDriver(PDRIVER_OBJECT DriverObject) {
    IoDeleteSymbolicLink(&g_usSymlinkName);
    IoDeleteDevice(DriverObject->DeviceObject);
    FltUnregisterFilter(g_FilterHandle);
    PsSetCreateProcessNotifyRoutine(CreateProcessNotifyRoutine, TRUE);
    DbgPrint("Driver Unloading\n");
}

// Driver entry point - when driver is loaded to kernel space
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) {
    UNREFERENCED_PARAMETER(RegistryPath);
    NTSTATUS status;
    DbgPrint("Driver Entry\n");

    RtlInitUnicodeString(&g_usDeviceName, L"\\Device\\SugiotAV");
    RtlInitUnicodeString(&g_usSymlinkName, L"\\DosDevices\\SugiotAV");

    status = IoCreateDevice(DriverObject, 0, &g_usDeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, &g_DeviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = IoCreateSymbolicLink(&g_usSymlinkName, &g_usDeviceName);
    if (!NT_SUCCESS(status)) {
        DbgPrint("IoCreateSymbolicLink Failed\n");
        IoDeleteDevice(g_DeviceObject);
        return status;
    }

    status = FltRegisterFilter(DriverObject, &FilterRegistration, &g_FilterHandle);
    if (!NT_SUCCESS(status)) {
        DbgPrint("FltRegisterFilter Failed\n");
        IoDeleteSymbolicLink(&g_usSymlinkName);
        IoDeleteDevice(g_DeviceObject);
        return status;
    }

    status = FltStartFiltering(g_FilterHandle);
    if (!NT_SUCCESS(status)) {
        DbgPrint("FltStartFiltering Failed\n");
        FltUnregisterFilter(g_FilterHandle);
        IoDeleteSymbolicLink(&g_usSymlinkName);
        IoDeleteDevice(g_DeviceObject);
        return status;
    }

    //Init GetProcessImageFileName
    UNICODE_STRING sPsGetProcessImageFileName = RTL_CONSTANT_STRING(L"PsGetProcessImageFileName");
    gGetProcessImageFileName = (GET_PROCESS_IMAGE_NAME)MmGetSystemRoutineAddress(&sPsGetProcessImageFileName);
    if (gGetProcessImageFileName == NULL) {
        DbgPrint("GetProcessImageFileName address is null!\n");
        FltUnregisterFilter(g_FilterHandle);
        IoDeleteSymbolicLink(&g_usSymlinkName);
        IoDeleteDevice(g_DeviceObject);
        return status;
    }

    //Init GetProcessImageFileName
    /*
    UNICODE_STRING sZwReadVirtualMemory = RTL_CONSTANT_STRING(L"NtReadVirtualMemory");
    gZwReadVirtualMemory = (ZwReadVirtualMemory)MmGetSystemRoutineAddress(&sZwReadVirtualMemory);
    if (gZwReadVirtualMemory == NULL) {
        DbgPrint("ZwReadVirtualMemory address is null!\n");
        FltUnregisterFilter(g_FilterHandle);
        IoDeleteSymbolicLink(&g_usSymlinkName);
        IoDeleteDevice(g_DeviceObject);
        return status;
    }
    */

    //Init MmCopyVirtualMemory
    UNICODE_STRING sMmCopyVirtualMemory = RTL_CONSTANT_STRING(L"MmCopyVirtualMemory");
    gMmCopyVirtualMemory = (MmCopyVirtualMemory)MmGetSystemRoutineAddress(&sMmCopyVirtualMemory);
    if (gMmCopyVirtualMemory == NULL) {
        DbgPrint("MmCopyVirtualMemory address is null!\n");
        FltUnregisterFilter(g_FilterHandle);
        IoDeleteSymbolicLink(&g_usSymlinkName);
        IoDeleteDevice(g_DeviceObject);
        return status;
    }

    //Init GetProcessImageFileName
    UNICODE_STRING sPsGetProcessSectionBaseAddress = RTL_CONSTANT_STRING(L"PsGetProcessSectionBaseAddress");
    gPsGetProcessSectionBaseAddress = (PsGetProcessSectionBaseAddress)MmGetSystemRoutineAddress(&sPsGetProcessSectionBaseAddress);
    if (gPsGetProcessSectionBaseAddress == NULL) {
        DbgPrint("PsGetProcessSectionBaseAddress address is null!\n");
        FltUnregisterFilter(g_FilterHandle);
        IoDeleteSymbolicLink(&g_usSymlinkName);
        IoDeleteDevice(g_DeviceObject);
        return status;
    }

    // Register call back to CreateProcessNotifyRoutine
    status = PsSetCreateProcessNotifyRoutine(CreateProcessNotifyRoutine, FALSE);
    if (!NT_SUCCESS(status)) {
        DbgPrint("PsSetCreateProcessNotifyRoutine Failed\n");
        FltUnregisterFilter(g_FilterHandle);
        IoDeleteSymbolicLink(&g_usSymlinkName);
        IoDeleteDevice(g_DeviceObject);
        return status;
    }

    // Register IRP handlers
    DriverObject->MajorFunction[IRP_MJ_CREATE] = CreateCloseRoutine;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = CreateCloseRoutine;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DeviceControlRoutine;
    DriverObject->DriverUnload = UnloadDriver;

    DbgPrint("Successful start!\n");
    return STATUS_SUCCESS;
}