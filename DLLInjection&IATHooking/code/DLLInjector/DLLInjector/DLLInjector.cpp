#include <windows.h>
#include <iostream>
#include <vector>
#include <tlhelp32.h>


std::vector<DWORD> FindProcessId(const std::string& processName) {
    std::vector<DWORD> processIds;
    PROCESSENTRY32 processInfo;
    processInfo.dwSize = sizeof(processInfo);

    HANDLE processesSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
    if (processesSnapshot == INVALID_HANDLE_VALUE) {
        return processIds;
    }

    Process32First(processesSnapshot, &processInfo);
    if (!processName.compare(processInfo.szExeFile)) {
        processIds.push_back(processInfo.th32ProcessID);
    }

    while (Process32Next(processesSnapshot, &processInfo)) {
        if (!processName.compare(processInfo.szExeFile)) {
            processIds.push_back(processInfo.th32ProcessID);
        }
    }

    CloseHandle(processesSnapshot);
    return processIds;
}

bool InjectDLL(DWORD pid, const char* dllPath) {
    // 1. Retrieve the address of LoadLibraryA from the current process
    HMODULE hKernel32 = GetModuleHandle("Kernel32");
    FARPROC pLoadLibraryA = GetProcAddress(hKernel32, "LoadLibraryA");
    if (pLoadLibraryA == NULL) {
        std::cerr << "Error: Could not find LoadLibraryA function address.\n";
        return false;
    }

    // 2. Open the target process, allocate memory, and write the DLL path to it
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (hProcess == NULL) {
        std::cerr << "Error: Could not open target process.\n";
        return false;
    }

    LPVOID pRemoteMemory = VirtualAllocEx(hProcess, NULL, strlen(dllPath) + 1, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE);
    if (pRemoteMemory == NULL) {
        std::cerr << "Error: Could not allocate memory in target process.\n";
        CloseHandle(hProcess);
        return false;
    }

    if (!WriteProcessMemory(hProcess, pRemoteMemory, (void*)dllPath, strlen(dllPath) + 1, NULL)) {
        std::cerr << "Error: Could not write to process memory.\n";
        VirtualFreeEx(hProcess, pRemoteMemory, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return false;
    }

    // 3. Create a remote thread to load the DLL
    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pLoadLibraryA, pRemoteMemory, 0, NULL);
    if (hThread == NULL) {
        std::cerr << "Error: Could not create remote thread.\n";
        VirtualFreeEx(hProcess, pRemoteMemory, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return false;
    }

    std::cout << "DLL injection successful.\n";

    // Wait for the remote thread to finish
    WaitForSingleObject(hThread, INFINITE);

    // Cleanup
    VirtualFreeEx(hProcess, pRemoteMemory, 0, MEM_RELEASE);
    CloseHandle(hThread);
    CloseHandle(hProcess);

    std::cout << "Cleanup successful.\n";
    return true;
}

int main(int argc, char* argv[]) {
    // DLL for notepad.exe and mspaint.exe
    //const char* dllPath = "C:\\Users\\user\\source\\repos\\Injected\\x64\\Debug\\Injected.dll";
    //DLL for cmd.exe and NETSTAT.EXE
    const char* dllPath = "C:\\Users\\user\\source\\repos\\IAThooking\\x64\\Debug\\IAThooking.dll";


    if (argc == 3) {
        dllPath = argv[2];
    }

    if (argc >= 2) {
        DWORD pid = std::atoi(argv[1]);
        if (!InjectDLL(pid, dllPath)) {
            std::cerr << "Injection failed for PID: " << pid << "\n";
        }
    }
    else {
        // Auto mode - find all notepad.exe/mspaint.exe instances and inject the DLL
        //auto pids = FindProcessId("notepad.exe");
        auto pids = FindProcessId("mspaint.exe");
        if (pids.empty()) {
            std::cerr << "No notepad.exe instances found.\n";
            return 1;
        }
        for (DWORD pid : pids) {
            if (!InjectDLL(pid, dllPath)) {
                std::cerr << "Injection failed for PID: " << pid << "\n";
            }
            else {
                std::cout << "Injected successfully to PID: " << pid << "\n";
            }
        }
	}

    return 0;
}


