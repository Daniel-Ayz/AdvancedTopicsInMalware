#include <iostream>
#include <windows.h>
#include <tlhelp32.h>
#include <tchar.h>

// Helper function to convert a module name to lowercase for case-insensitive comparison
//std::wstring ToLower(const std::wstring& str) {
//    std::wstring lowerStr = str;
//    std::transform(lowerStr.begin(), lowerStr.end(), lowerStr.begin(), ::tolower);
//    return lowerStr;
//}

// Function to find a module in the target process by name and return its base address (handle)
//HMODULE GetRemoteModuleHandle(DWORD processId, const wchar_t* moduleName) {
//    HMODULE hModule = NULL;
//    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, processId);
//    if (hSnapshot != INVALID_HANDLE_VALUE) {
//        MODULEENTRY32W me32;
//        me32.dwSize = sizeof(MODULEENTRY32W);
//        if (Module32FirstW(hSnapshot, &me32)) {
//            do {
//                std::cout << "Module name: " << me32.modBaseAddr << std::endl;
//                if (me32.szModule == moduleName) {
//                    hModule = me32.hModule;
//                    break;
//                }
//            } while (Module32NextW(hSnapshot, &me32));
//        }
//        CloseHandle(hSnapshot);
//    }
//    return hModule;
//}

char* GetModuleBase(const wchar_t* ModuleName, DWORD procID)
{
    MODULEENTRY32 ModuleEntry = { 0 };
    HANDLE SnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, procID);

    if (!SnapShot) return NULL;

    ModuleEntry.dwSize = sizeof(ModuleEntry);

    if (!Module32First(SnapShot, &ModuleEntry)) return NULL;

    do
    {
        if (!wcscmp(ModuleEntry.szModule, ModuleName))
        {
            CloseHandle(SnapShot);
            return (char*)ModuleEntry.modBaseAddr;
        }
    } while (Module32Next(SnapShot, &ModuleEntry));

    CloseHandle(SnapShot);
    return NULL;
}


BOOL UnloadRemoteDLL(DWORD processId, const wchar_t* dllName) {
    std::cout << "Unloading DLL from process " << processId << "..." << std::endl;
    BOOL result = FALSE;
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processId);
    if (hProcess) {
        std::cout << "Process handle opened." << std::endl;
        //HMODULE hMod = GetRemoteModuleHandle(processId, dllName);
        HMODULE dllBase = (HMODULE)GetModuleBase(dllName, processId);
        if (dllBase) {
            std::cout << "Module handle obtained." << std::endl;
            HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0,
                (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "FreeLibrary"),
                dllBase, 0, NULL);
            if (hThread) {
                std::cout << "Remote thread created." << std::endl;
                WaitForSingleObject(hThread, INFINITE);
                CloseHandle(hThread);
                result = TRUE;
            }
        }
        CloseHandle(hProcess);
    }
    return result;
}

int main(int argc, char*argv[])
{
    const wchar_t* dllName = L"IAThooking.dll";
    if (argc != 2) {
        std::cerr << "Usage: " << argv[0] << " <PID>" << std::endl;
        return 1;
    }
    // Convert PID from string to DWORD
    DWORD pid = std::atoi(argv[1]);
    if (pid == 0) {
        std::cerr << "Invalid PID." << std::endl;
        return 1;
    }

    std::cout << "Unloading DLL from process " << pid << "..." << std::endl;
    BOOL result = UnloadRemoteDLL(pid, dllName);
    if (result) {
        std::cout << "DLL unloaded successfully." << std::endl;
    }
    else {
        std::cerr << "Failed to unload DLL." << std::endl;
    }
}

