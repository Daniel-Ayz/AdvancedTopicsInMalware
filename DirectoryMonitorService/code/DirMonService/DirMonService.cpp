#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <string>

wchar_t serviceName[] = L"DirMonService";
LPWSTR SERVICE_NAME = serviceName;

SERVICE_STATUS        g_ServiceStatus = { 0 };
SERVICE_STATUS_HANDLE g_StatusHandle = NULL;
HANDLE                g_ServiceStopEvent = INVALID_HANDLE_VALUE;
HANDLE                g_ServicePauseEvent = INVALID_HANDLE_VALUE;
HANDLE                g_ServiceContinueEvent = INVALID_HANDLE_VALUE;



VOID WINAPI ServiceMain(DWORD argc, LPTSTR* argv);
VOID WINAPI ServiceCtrlHandler(DWORD);
DWORD WINAPI ServiceWorkerThread(LPVOID lpParam);

int _tmain(int argc, TCHAR* argv[]) {
    SERVICE_TABLE_ENTRY ServiceTable[] = {
        {SERVICE_NAME, (LPSERVICE_MAIN_FUNCTION)ServiceMain},
        {NULL, NULL}
    };

    if (!StartServiceCtrlDispatcher(ServiceTable)) {
        return GetLastError();
    }

    return 0;
}

VOID WINAPI ServiceMain(DWORD argc, LPTSTR* argv) {
    // Register the handler function for the service
    g_StatusHandle = RegisterServiceCtrlHandler(SERVICE_NAME, ServiceCtrlHandler);
    if (g_StatusHandle == NULL) {
        return;
    }

    // START PENDING
    g_ServiceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    g_ServiceStatus.dwControlsAccepted = 0;
    g_ServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    SetServiceStatus(g_StatusHandle, &g_ServiceStatus);

    //Set Stop event
    g_ServiceStopEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    g_ServicePauseEvent = CreateEvent(NULL, TRUE, FALSE, NULL); // Initially not paused
    g_ServiceContinueEvent = CreateEvent(NULL, TRUE, FALSE, NULL); // Initially not resumed


    if (g_ServiceStopEvent == NULL || g_ServicePauseEvent == NULL || g_ServiceContinueEvent == NULL) {
        g_ServiceStatus.dwCurrentState = SERVICE_STOPPED;
        SetServiceStatus(g_StatusHandle, &g_ServiceStatus);
        return;
    }

    // RUNNING
    g_ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE;
    g_ServiceStatus.dwCurrentState = SERVICE_RUNNING;
    SetServiceStatus(g_StatusHandle, &g_ServiceStatus);

    // Start monitoring thread
    HANDLE hThread = CreateThread(NULL, 0, ServiceWorkerThread, argv, 0, NULL);

    // Wait until the service is stopped
    WaitForSingleObject(hThread, INFINITE);

    CloseHandle(g_ServiceStopEvent);

    g_ServiceStatus.dwCurrentState = SERVICE_STOPPED;
    SetServiceStatus(g_StatusHandle, &g_ServiceStatus);
}


// Control handler function
VOID WINAPI ServiceCtrlHandler(DWORD CtrlCode) {
    switch (CtrlCode) {
    case SERVICE_CONTROL_STOP:
        SetEvent(g_ServiceStopEvent);  // Signal the service to stop
        g_ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
        break;

    case SERVICE_CONTROL_PAUSE:
        SetEvent(g_ServicePauseEvent);  // Reset the pause event to block the worker thread
        g_ServiceStatus.dwCurrentState = SERVICE_PAUSED;
        break;

    case SERVICE_CONTROL_CONTINUE:
        SetEvent(g_ServiceContinueEvent);  // Set the pause event to unblock the worker thread
        g_ServiceStatus.dwCurrentState = SERVICE_RUNNING;
        break;

    default:
        break;
    }
    SetServiceStatus(g_StatusHandle, &g_ServiceStatus);
}


// Helper function to log changes with timestamp and action
void LogChange(HANDLE logFile, const std::wstring& action, const std::wstring& fileName) {
    SYSTEMTIME st;
    GetLocalTime(&st);
    WCHAR timeBuffer[100];
    swprintf_s(timeBuffer, sizeof(timeBuffer) / sizeof(WCHAR), L"%04d-%02d-%02d %02d:%02d:%02d - %s: %s\n",
        st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, action.c_str(), fileName.c_str());
    DWORD written;
    WriteFile(logFile, timeBuffer, wcslen(timeBuffer) * sizeof(WCHAR), &written, NULL);
}

// Correct usage of asynchronous IO with ReadDirectoryChangesW
// Link: https://gist.github.com/nickav/a57009d4fcc3b527ed0f5c9cf30618f8
DWORD WINAPI ServiceWorkerThread(LPVOID lpParam) {
    LPTSTR* argv = (LPTSTR*)lpParam;
    LPCWSTR directoryToWatch = argv[1];
    LPCWSTR logFilePath = argv[2];

    HANDLE dir = CreateFile(directoryToWatch, FILE_LIST_DIRECTORY, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED, NULL);
    if (dir == INVALID_HANDLE_VALUE) {
        return 1; // Error handling for invalid handle
    }

    HANDLE logFile = CreateFile(logFilePath, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (logFile == INVALID_HANDLE_VALUE) {
        CloseHandle(dir);
        return 1; // Error handling for log file creation failure
    }

    char buffer[1024];
    OVERLAPPED overlapped = { 0 };
    overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL); // Event for overlapped I/O

    ReadDirectoryChangesW(dir, buffer, sizeof(buffer), TRUE,
        FILE_NOTIFY_CHANGE_FILE_NAME | FILE_NOTIFY_CHANGE_DIR_NAME | FILE_NOTIFY_CHANGE_LAST_WRITE,
        NULL, &overlapped, NULL);

    HANDLE events[3] = { g_ServiceStopEvent, overlapped.hEvent, g_ServicePauseEvent };

    while (true) {
        DWORD waitStatus = WaitForMultipleObjects(3, events, FALSE, INFINITE);
        if (waitStatus == WAIT_OBJECT_0) {
            CancelIo(dir); // Ensure any pending IO is cancelled
            break; // Stop event fired
        }
        else if (waitStatus == WAIT_OBJECT_0 + 2) {
            // Pause event triggered, wait for either continue or stop
            HANDLE pauseEvents[2] = {g_ServiceStopEvent, g_ServiceContinueEvent};
            ResetEvent(g_ServicePauseEvent);
            DWORD pauseWaitStatus = WaitForMultipleObjects(2, pauseEvents, FALSE, INFINITE);
            if (pauseWaitStatus == WAIT_OBJECT_0) {
                CancelIo(dir); // Stop event fired, cancel any pending IO
                break;
            }

            // If resume (g_ServiceContinueEvent set), continue the main loop
            ResetEvent(g_ServiceContinueEvent);
            continue;
        }
        else if (waitStatus == WAIT_OBJECT_0 + 1) {
            // Service is not paused, process events
            DWORD bytesTransferred;
            GetOverlappedResult(dir, &overlapped, &bytesTransferred, FALSE);
            if (bytesTransferred > 0) {
                FILE_NOTIFY_INFORMATION* event = (FILE_NOTIFY_INFORMATION*)buffer;
                do {
                    std::wstring fileName(event->FileName, event->FileNameLength / sizeof(WCHAR));
                    std::wstring action;
                    switch (event->Action) {
                    case FILE_ACTION_ADDED: action = L"File added"; break;
                    case FILE_ACTION_REMOVED: action = L"File removed"; break;
                    case FILE_ACTION_MODIFIED: action = L"File modified"; break;
                    case FILE_ACTION_RENAMED_OLD_NAME: action = L"Renamed from"; break;
                    case FILE_ACTION_RENAMED_NEW_NAME: action = L"Renamed to"; break;
                    default: action = L"Unknown action"; break;
                    }
                    LogChange(logFile, action, fileName);

                    if (!event->NextEntryOffset) break;
                    *((uint8_t**)&event) += event->NextEntryOffset;
                } while (true);
            }
            // Re-issue the ReadDirectoryChangesW for continued monitoring
            ReadDirectoryChangesW(dir, buffer, sizeof(buffer), TRUE,
                FILE_NOTIFY_CHANGE_FILE_NAME | FILE_NOTIFY_CHANGE_DIR_NAME | FILE_NOTIFY_CHANGE_LAST_WRITE,
                NULL, &overlapped, NULL);
        }
    }

    CloseHandle(overlapped.hEvent);
    CloseHandle(dir);
    CloseHandle(logFile);
    return ERROR_SUCCESS;
}


