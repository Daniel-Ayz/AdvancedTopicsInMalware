// dllmain.cpp : Defines the entry point for the DLL application.
#include "pch.h"
#include "windows.h"
#include "timeapi.h"
#include <iostream>
#include <intrin.h>
#include <strsafe.h>


// -----------------------------------------TIME PARAMETER--------------------------------------
ULONGLONG SUSPICIOUSLY_CLOSE_TIME = 150; // 150 milliseconds
// -----------------------------------------TIME PARAMETER--------------------------------------


// Log file path from Injector
LPCWSTR filePathFromInjector = NULL;

// Function prototypes
void captureInitialTimes();
void checkTimes();

// Global variables to store initial values of the time-based functions (track each function independantly)
bool initialTickCountCaptured = false;
bool initialQueryPerformanceCounterCaptured = false;
bool initialTimeGetTimeCaptured = false;
bool initialSystemTimeCaptured = false;
bool initialLocalTimeCaptured = false;

bool initialValuesCaptured = false;

SYSTEMTIME initialLocalTime;
SYSTEMTIME initialSystemTime;
DWORD initialTickCount = 0;
ULONGLONG initialTickCount64 = 0;
LARGE_INTEGER initialPerformanceCounter;
DWORD initialTimeGetTime = 0;
LARGE_INTEGER performanceFrequency;

// Track all time functions together
bool globalTimeCaptured = false;
ULONGLONG globalTime = 0;


// define time-based detection function protorypes
// define GetTickCount prototype
using PrototypeGetTickCount = DWORD (WINAPI*)();
PrototypeGetTickCount RealGetTickCount = nullptr;
// define GetTickCount64 prototype
using PrototypeGetTickCount64 = ULONGLONG (WINAPI*)();
PrototypeGetTickCount64 RealGetTickCount64 = nullptr;
// define QueryPerformanceCounter prototype
using PrototypeQueryPerformanceCounter = BOOL (WINAPI*)(LARGE_INTEGER* lpPerformanceCount);
PrototypeQueryPerformanceCounter RealQueryPerformanceCounter = nullptr;
// define timeGetTime prototype
using PrototypeTimeGetTime = DWORD (WINAPI*)();
PrototypeTimeGetTime RealTimeGetTime = nullptr;
// define GetSystemTime prototype
using PrototypeGetSystemTime = void (WINAPI*)(LPSYSTEMTIME lpSystemTime);
PrototypeGetSystemTime RealGetSystemTime = nullptr;
// define GetLocalTime prototype
using PrototypeGetLocalTime = void (WINAPI*)(LPSYSTEMTIME lpSystemTime);
PrototypeGetLocalTime RealGetLocalTime = nullptr;

// Helper Function to write to log file
BOOL WriteToFile(LPCWSTR str, LPCWSTR filePath) {
    // Open the file with write access, append to the end, and create the file if it doesn't exist
    HANDLE hFile = CreateFileW(filePath,
        FILE_APPEND_DATA,
        FILE_SHARE_READ,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        // Failed to open or create the file
        return FALSE;
    }

    DWORD bytesWritten;
    DWORD strLengthInBytes = static_cast<DWORD>(wcslen(str) * sizeof(wchar_t));
    BOOL result = WriteFile(hFile,           // Handle to the file
        str,             // Buffer to write from
        strLengthInBytes,  // Number of bytes to write
        &bytesWritten,   // Number of bytes that were written
        NULL);           // No overlapping structure

    // Write the newline if the string was written successfully
    if (result) {
        LPCWSTR newline = L"\r\n";
        DWORD newlineLengthInBytes = static_cast<DWORD>(wcslen(newline) * sizeof(wchar_t));
        WriteFile(hFile, newline, newlineLengthInBytes, &bytesWritten, NULL);
    }

    // Close the file handle
    CloseHandle(hFile);

    return result;
}

// Helper function to calculate elapsed time in milliseconds from SYSTEMTIME
DWORD calculateElapsedTime(const SYSTEMTIME& start, const SYSTEMTIME& end)
{
    FILETIME fStart, fEnd;
    ULARGE_INTEGER uStart, uEnd;

    SystemTimeToFileTime(&start, &fStart);
    SystemTimeToFileTime(&end, &fEnd);

    uStart.LowPart = fStart.dwLowDateTime;
    uStart.HighPart = fStart.dwHighDateTime;

    uEnd.LowPart = fEnd.dwLowDateTime;
    uEnd.HighPart = fEnd.dwHighDateTime;

    return static_cast<DWORD>((uEnd.QuadPart - uStart.QuadPart) / 10000); // Convert to milliseconds
}

// Capture initial values
void captureInitialTimes()
{
    GetLocalTime(&initialLocalTime);
    GetSystemTime(&initialSystemTime);
    initialTickCount = GetTickCount();
    initialTickCount64 = GetTickCount64();
    QueryPerformanceFrequency(&performanceFrequency);
    QueryPerformanceCounter(&initialPerformanceCounter);
    initialTimeGetTime = timeGetTime();
    initialValuesCaptured = true;

    std::cout << "Initial values captured!" << std::endl;
    std::cout << "Initial GetTickCount: " << initialTickCount << std::endl;
    std::cout << "Initial GetTickCount64: " << initialTickCount64 << std::endl;
    std::cout << "Initial QueryPerformanceCounter: " << initialPerformanceCounter.QuadPart << std::endl;
    std::cout << "Initial timeGetTime: " << initialTimeGetTime << std::endl;
    std::cout << "Initial GetLocalTime: " << initialLocalTime.wSecond << ":" << initialLocalTime.wMilliseconds << std::endl;
    std::cout << "Initial GetSystemTime: " << initialSystemTime.wSecond << ":" << initialSystemTime.wMilliseconds << std::endl;
}

void checkTimes()
{
    SYSTEMTIME currentLocalTime;
    SYSTEMTIME currentSystemTime;
    DWORD currentTickCount = GetTickCount();
    ULONGLONG currentTickCount64 = GetTickCount64();
    LARGE_INTEGER currentPerformanceCounter;
    DWORD currentTimeGetTime = timeGetTime();

    GetLocalTime(&currentLocalTime);
    GetSystemTime(&currentSystemTime);
    QueryPerformanceCounter(&currentPerformanceCounter);

    // Calculate differences
    DWORD elapsedTickCount = currentTickCount - initialTickCount;
    DWORD elapsedTickCount64 = static_cast<DWORD>(currentTickCount64 - initialTickCount64);
    double elapsedPerformanceCounter = static_cast<double>(currentPerformanceCounter.QuadPart - initialPerformanceCounter.QuadPart) / performanceFrequency.QuadPart * 1000.0;
    DWORD elapsedTimeGetTime = currentTimeGetTime - initialTimeGetTime;
    DWORD elapsedLocalTime = calculateElapsedTime(initialLocalTime, currentLocalTime);
    DWORD elapsedSystemTime = calculateElapsedTime(initialSystemTime, currentSystemTime);

    // Print differences
    std::cout << "Elapsed time (GetTickCount): " << elapsedTickCount << " ms" << std::endl;
    std::cout << "Elapsed time (GetTickCount64): " << elapsedTickCount64 << " ms" << std::endl;
    std::cout << "Elapsed time (QueryPerformanceCounter): " << elapsedPerformanceCounter << " ms" << std::endl;
    std::cout << "Elapsed time (timeGetTime): " << elapsedTimeGetTime << " ms" << std::endl;
    std::cout << "Elapsed time (GetLocalTime): " << elapsedLocalTime << " ms" << std::endl;
    std::cout << "Elapsed time (GetSystemTime): " << elapsedSystemTime << " ms" << std::endl;

    // Check for suspicious behavior
    if (elapsedTickCount < SUSPICIOUSLY_CLOSE_TIME) {
        std::cout << "Suspicious behavior detected with GetTickCount!" << std::endl;
    }
    if (elapsedTickCount64 < SUSPICIOUSLY_CLOSE_TIME) {
        std::cout << "Suspicious behavior detected with GetTickCount64!" << std::endl;
    }
    if (elapsedPerformanceCounter < SUSPICIOUSLY_CLOSE_TIME) {
        std::cout << "Suspicious behavior detected with QueryPerformanceCounter!" << std::endl;
    }
    if (elapsedTimeGetTime < SUSPICIOUSLY_CLOSE_TIME) {
        std::cout << "Suspicious behavior detected with timeGetTime!" << std::endl;
    }
    if (elapsedLocalTime < SUSPICIOUSLY_CLOSE_TIME) {
        std::cout << "Suspicious behavior detected with GetLocalTime!" << std::endl;
    }
    if (elapsedSystemTime < SUSPICIOUSLY_CLOSE_TIME) {
        std::cout << "Suspicious behavior detected with GetSystemTime!" << std::endl;
    }
}

void captureGlobalTime() {
	globalTime = GetTickCount64();
	globalTimeCaptured = true;
}

BOOL checkAntiForensicsViaGlobalTime(){
	ULONGLONG currentTime = GetTickCount64();
	ULONGLONG elapsedTime = currentTime - globalTime;
    // Set globalTime to current time for future checks
    globalTime = currentTime;

    if (elapsedTime < 150) {
		std::cout << "Time Based Anti Forensics Technique Detected!" << std::endl;
        std::cout << "Elapsed time between time queries: " << elapsedTime << " ms" << std::endl;
        return TRUE;
	}
    return FALSE;
}

 //Function to format the log message
LPCWSTR format(void* returnAddress, LPCWSTR functionName)
{
    static WCHAR buffer[256];
    WCHAR addressBuffer[16];
    // Format the address as a hexadecimal string
    StringCchPrintfW(addressBuffer, sizeof(addressBuffer) / sizeof(WCHAR), L"%08X", reinterpret_cast<uintptr_t>(returnAddress));

    // Format the final log message
    StringCchPrintfW(buffer, sizeof(buffer) / sizeof(WCHAR),
        L"Anti-Forensic measurements using <%s> detected at address [%s]", functionName, addressBuffer);
    return buffer;
}

void DetectAntiForensicsGlobal(void* returnAddress, LPCWSTR functionName) {
    if (!globalTimeCaptured) {
        captureGlobalTime();
    }
    else {
        if (checkAntiForensicsViaGlobalTime()) {
            // Write to log file
			LPCWSTR logMessage = format(returnAddress, functionName);
            LPCWSTR logFilePath = filePathFromInjector;
			WriteToFile(logMessage, logFilePath);
        }
    }
}

// Hooked functions
DWORD WINAPI HookedGetTickCount()
{
    //std::cout << "GetTickCount Hook activated!!!" << std::endl;
	DWORD tickCount = RealGetTickCount();
    
    // This code snippet will track all time functions independently when placed inside all the hook functions
    /*if (!initialValuesCaptured) {
        captureInitialTimes();
    }
    else {
        checkTimes();
        captureInitialTimes();
    }*/

    // This code snippet will track all time functions together
    void* returnAddress = _ReturnAddress();
    DetectAntiForensicsGlobal(returnAddress, L"GetTickCount");

	return tickCount;
}

ULONGLONG WINAPI HookedGetTickCount64()
{
	ULONGLONG tickCount = RealGetTickCount64();
    //std::cout << "GetTickCount64 Hook activated!!!" << std::endl;
    void* returnAddress = _ReturnAddress();
    DetectAntiForensicsGlobal(returnAddress, L"GetTickCount64");

	return tickCount;
}

BOOL WINAPI HookedQueryPerformanceCounter(LARGE_INTEGER* lpPerformanceCount)
{
	BOOL result = RealQueryPerformanceCounter(lpPerformanceCount);
    //std::cout << "QueryPerformanceCounter Hook activated!!!" << std::endl;
    void* returnAddress = _ReturnAddress();
    DetectAntiForensicsGlobal(returnAddress, L"QueryPerformanceCounter");

	return result;
}

DWORD WINAPI HookedTimeGetTime()
{
	DWORD time = RealTimeGetTime();
    //std::cout << "TimeGetTime Hook activated!!!" << std::endl;
    void* returnAddress = _ReturnAddress();
    DetectAntiForensicsGlobal(returnAddress, L"TimeGetTime");

	return time;
}

void WINAPI HookedGetSystemTime(LPSYSTEMTIME lpSystemTime)
{
	RealGetSystemTime(lpSystemTime);
    //std::cout << "GetSystemTime Hook activated!!!" << std::endl;
    void* returnAddress = _ReturnAddress();
    DetectAntiForensicsGlobal(returnAddress, L"GetSystemTime");
    
}

void WINAPI HookedGetLocalTime(LPSYSTEMTIME lpSystemTime)
{
	RealGetLocalTime(lpSystemTime);
    //std::cout << "GetLocalTime Hook activated!!!" << std::endl;
    void* returnAddress = _ReturnAddress();
    DetectAntiForensicsGlobal(returnAddress, L"GetLocalTime");
    
}

//Function to save the original function pointers
BOOL SaveOriginalFunction(LPCSTR importModuleName, LPCSTR functionName, void** originalSaveAddress ) {
    HMODULE hModule = GetModuleHandleA(importModuleName);
    if (hModule) {
        FARPROC pFunc = GetProcAddress(hModule, functionName);
        if (pFunc) {
            *originalSaveAddress = (void*)pFunc;
            return TRUE;
        }
    }
    return FALSE;
}

// Function to get a pointer to the IAT.
PIMAGE_IMPORT_DESCRIPTOR GetIATPointer(LPVOID imageBase) {

    // get the DOS header
    PIMAGE_DOS_HEADER dosHeaders = (PIMAGE_DOS_HEADER)imageBase;
    // get the NT headers
    PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)imageBase + dosHeaders->e_lfanew);
    // get the import descriptor
    PIMAGE_IMPORT_DESCRIPTOR importDescriptor = NULL;
    IMAGE_DATA_DIRECTORY importsDirectory = ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
    importDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)(importsDirectory.VirtualAddress + (DWORD_PTR)imageBase);
    return importDescriptor; // This points to the IAT.
}

//PatchIAT function to patch the IAT.
bool HookIAT(LPCSTR importModuleName, LPCSTR importFunctionName, DWORD_PTR newFunction) {
    // get the base address of the current module
    LPVOID imageBase = GetModuleHandle(NULL);

    // Get the IAT pointer
    PIMAGE_IMPORT_DESCRIPTOR importDescriptor = GetIATPointer(imageBase);
    if (importDescriptor == NULL) {
        std::cout << "IAT not found" << std::endl;
        return false;
    }

    //std::cout << "IAT found" << std::endl;

    LPCSTR libraryName = NULL;
    HMODULE library = NULL;
    PIMAGE_IMPORT_BY_NAME functionName = NULL;


    // Loop through the import descriptors to find the one we want
    while (importDescriptor->Name != NULL) {

        libraryName = (LPCSTR)importDescriptor->Name + (DWORD_PTR)imageBase;

        //std::cout << "Module name: " << libraryName << std::endl;

        if (strcmp(libraryName, importModuleName) == 0) {

            //std::cout << "Module found: " << libraryName << std::endl;

            // Get the original and first thunk
            PIMAGE_THUNK_DATA originalFirstThunk = NULL;
            PIMAGE_THUNK_DATA firstThunk = NULL;
            originalFirstThunk = (PIMAGE_THUNK_DATA)((DWORD_PTR)imageBase + importDescriptor->OriginalFirstThunk);
            firstThunk = (PIMAGE_THUNK_DATA)((DWORD_PTR)imageBase + importDescriptor->FirstThunk);

            // Loop through the import address table
            while (originalFirstThunk->u1.AddressOfData != NULL)
            {
                functionName = (PIMAGE_IMPORT_BY_NAME)((DWORD_PTR)imageBase + originalFirstThunk->u1.AddressOfData);

                //std::cout << "Function name: " << functionName->Name << std::endl;


                if (std::string(functionName->Name).compare(importFunctionName) == 0)
                {
                    //std::cout << "Function found: " << functionName->Name << std::endl;

                    SIZE_T bytesWritten = 0;
                    DWORD oldProtect = 0;
                    VirtualProtect((LPVOID)(&firstThunk->u1.Function), 8, PAGE_READWRITE, &oldProtect);

                    // swap MessageBoxA address with address of hookedMessageBox
                    firstThunk->u1.Function = newFunction;

                    std::cout << "Function hooked: " << functionName->Name << std::endl;

                    VirtualProtect((LPVOID)(&firstThunk->u1.Function), 8, oldProtect, &oldProtect);
                }
                ++originalFirstThunk;
                ++firstThunk;
            }
        }
        importDescriptor++;
    }
    return true;
}

// Save and hook the original functions
void SaveAndHookOriginalFunctions() {
    if (SaveOriginalFunction("KERNEL32.dll", "GetTickCount", (void**)&RealGetTickCount)) {
		HookIAT("KERNEL32.dll", "GetTickCount", (DWORD_PTR)HookedGetTickCount);
	}
    if (SaveOriginalFunction("KERNEL32.dll", "GetTickCount64", (void**)&RealGetTickCount64)) {
		HookIAT("KERNEL32.dll", "GetTickCount64", (DWORD_PTR)HookedGetTickCount64);
	}
    if (SaveOriginalFunction("KERNEL32.dll", "QueryPerformanceCounter", (void**)&RealQueryPerformanceCounter)) {
		HookIAT("KERNEL32.dll", "QueryPerformanceCounter", (DWORD_PTR)HookedQueryPerformanceCounter);
	}
    if (SaveOriginalFunction("WINMM.dll", "timeGetTime", (void**)&RealTimeGetTime)) {
		HookIAT("WINMM.dll", "timeGetTime", (DWORD_PTR)HookedTimeGetTime);
	}
    if (SaveOriginalFunction("KERNEL32.dll", "GetSystemTime", (void**)&RealGetSystemTime)) {
		HookIAT("KERNEL32.dll", "GetSystemTime", (DWORD_PTR)HookedGetSystemTime);
	}
    if (SaveOriginalFunction("KERNEL32.dll", "GetLocalTime", (void**)&RealGetLocalTime)) {
		HookIAT("KERNEL32.dll", "GetLocalTime", (DWORD_PTR)HookedGetLocalTime);
	}
}

// Helper function to convert char* to LPCWSTR (wide string)
LPCWSTR ConvertToLPCWSTR(const char* charArray) {
    int wcharCount = MultiByteToWideChar(CP_UTF8, 0, charArray, -1, NULL, 0);
    wchar_t* wString = new wchar_t[wcharCount];
    MultiByteToWideChar(CP_UTF8, 0, charArray, -1, wString, wcharCount);
    return wString;
}

// Helper Function to parse the input string
char* parseToken(const char*& input, char delimiter) {
    int length = 0;
    while (input[length] != delimiter && input[length] != '\0') {
        length++;
    }

    char* token = new char[length + 1];
    for (int i = 0; i < length; ++i) {
        token[i] = input[i];
    }
    token[length] = '\0';

    input += length + 1; // move input pointer to next token
    return token;
}

// Helper Function to parse the filename from the input string
char* parseFilename(const char*& input) {
    return parseToken(input, '|');
}

// Helper Get logfile name via Pipe
LPCWSTR GetLogFileName() {
    HANDLE hPipe = CreateFileW(
        L"\\\\.\\pipe\\MyPipe",
        GENERIC_READ,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (hPipe == INVALID_HANDLE_VALUE) {
        MessageBoxW(NULL, L"Failed to connect to the named pipe.", L"Error", MB_OK);
        return FALSE;
    }

    char buffer[1024];
    DWORD bytesRead;
    if (ReadFile(hPipe, buffer, sizeof(buffer), &bytesRead, NULL) && bytesRead > 0) {
        buffer[bytesRead] = '\0'; // Ensure null-termination
    }
    else {
        MessageBoxW(NULL, L"Failed to read from the named pipe.", L"Error", MB_OK);
    }
    CloseHandle(hPipe);

    // Parse the buffer
    const char* input = buffer;
    char* filename = parseFilename(input);
    LPCWSTR filePathFromInjector = ConvertToLPCWSTR(filename);
    return filePathFromInjector;
}




BOOL APIENTRY DllMain(HMODULE hModule,
    DWORD  ul_reason_for_call,
    LPVOID lpReserved
)
{
    switch (ul_reason_for_call)
    {
        case DLL_PROCESS_ATTACH: 
        {
            std::cout << "DLL_PROCESS_ATTACH" << std::endl;
            filePathFromInjector = GetLogFileName();
            //MessageBoxW(NULL, filePathFromInjector, L"Log File Path", MB_OK);
            SaveAndHookOriginalFunctions();
            std::cout << "DLL_PROCESS_ATTACH completed" << std::endl;
            break;
        }
        case DLL_THREAD_ATTACH:
            break;
        case DLL_THREAD_DETACH:
            break;
        case DLL_PROCESS_DETACH:
        {
            //delete filePathFromInjector;
            break;
        }
        break;
    }
    return TRUE;
}

