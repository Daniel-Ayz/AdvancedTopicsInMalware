#include <iostream>
#include <string>
#include <vector>
#include <windows.h>
#include <tlhelp32.h>
#include <sstream>

const char* DLL_PATH = "C:\\Users\\user\\source\\repos\\AntiAntiForensics\\x64\\Debug\\TimeBasedDetectorDLL.dll";


std::string unparseString(const std::string& message, bool flag1, bool flag2) {
    std::ostringstream oss;
    oss << message << "|" << (flag1 ? "True" : "False") << "|" << (flag2 ? "True" : "False");
    return oss.str();
}

//Function to open named pipe for communication with the DLL
HANDLE OpenPipe() {
    HANDLE hPipe;
    LPCWSTR pipeName = L"\\\\.\\pipe\\MyPipe";

    // Create a named pipe
    hPipe = CreateNamedPipeW(
        pipeName,
        PIPE_ACCESS_OUTBOUND,
        PIPE_TYPE_BYTE | PIPE_WAIT,
        1,
        0,
        0,
        0,
        NULL);

    if (hPipe == INVALID_HANDLE_VALUE) {
        std::cerr << "CreateNamedPipe failed: " << GetLastError() << std::endl;
        return NULL;
    }

    return hPipe;
}

// Function to send data via named pipe to the DLL
BOOL SendDataViaPipe(HANDLE hPipe, const char* data) {
    std::cout << "Waiting for DLL to connect..." << std::endl;

    // Wait for a client to connect
    if (!ConnectNamedPipe(hPipe, NULL)) {
        std::cerr << "ConnectNamedPipe failed: " << GetLastError() << std::endl;
        CloseHandle(hPipe);
        return 1;
    }

    std::cout << "Sending data..." << std::endl;

    // Send data
    DWORD bytesWritten;
    if (!WriteFile(hPipe, data, strlen(data) + 1, &bytesWritten, NULL)) {
        std::cerr << "WriteFile failed: " << GetLastError() << std::endl;
        CloseHandle(hPipe);
        return 1;
    }

    // Close the pipe
    CloseHandle(hPipe);
    return 0;
}

// Struct to hold parsed arguments
struct ParsedArgs {
    std::string programToCheck;
    std::string logFile;
};

// Function to display usage information
void displayUsage() {
    std::cout << "Usage: AntiForensicsDetector.exe <program.exe> -f <logfile>" << std::endl;
}

// Function to parse command-line arguments
ParsedArgs parseArguments(int argc, char* argv[]) {
    ParsedArgs args;
    bool hasLogFile = false;

    if (argc != 4) {
        std::cerr << "Error: Incorrect number of arguments." << std::endl;
        displayUsage();
        exit(1);
    }

    for (int i = 1; i < argc; ++i) {
        std::string arg = argv[i];

        if (i == 1) {
            args.programToCheck = arg;
        }
        else if (arg == "-f") {
            if (i + 1 < argc) {
                args.logFile = argv[++i];
                hasLogFile = true;
            }
            else {
                std::cerr << "Error: No log file specified after -f." << std::endl;
                displayUsage();
                exit(1);
            }
        }
        else {
            std::cerr << "Error: Unknown argument " << arg << std::endl;
            displayUsage();
            exit(1);
        }
    }

    if (!hasLogFile) {
        std::cerr << "Error: -f flag is missing." << std::endl;
        displayUsage();
        exit(1);
    }

    return args;
}

bool InjectDLL(DWORD pid, const char* dllPath, HANDLE hPipe, const char* logFileName) {
    // 1. Retrieve the address of LoadLibraryA from the current process
    HMODULE hKernel32 = GetModuleHandleA("Kernel32");
    FARPROC pLoadLibraryA = GetProcAddress(hKernel32, "LoadLibraryA");
    if (pLoadLibraryA == NULL) {
        std::cerr << "Error: Could not find LoadLibraryA function address.\n";
        return false;
    }

    // 2. Open the target process, allocate memory, and write the DLL path to it
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (hProcess == NULL) {
        std::cerr << "Error: Could not open target process.\n";
        return false;
    }

    LPVOID pRemoteMemory = VirtualAllocEx(hProcess, NULL, strlen(dllPath) + 1, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE);
    if (pRemoteMemory == NULL) {
        std::cerr << "Error: Could not allocate memory in target process.\n";
        CloseHandle(hProcess);
        return false;
    }

    if (!WriteProcessMemory(hProcess, pRemoteMemory, (void*)dllPath, strlen(dllPath) + 1, NULL)) {
        std::cerr << "Error: Could not write to process memory.\n";
        VirtualFreeEx(hProcess, pRemoteMemory, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return false;
    }

    // 3. Create a remote thread to load the DLL
    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pLoadLibraryA, pRemoteMemory, 0, NULL);
    if (hThread == NULL) {
        std::cerr << "Error: Could not create remote thread.\n";
        VirtualFreeEx(hProcess, pRemoteMemory, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return false;
    }

    std::cout << "DLL injection successful." << std::endl;

    // Send data via named pipe to the DLL
    if (SendDataViaPipe(hPipe, logFileName)) {
        throw std::runtime_error("Error: Failed to send data via pipe.");
    }

    std::cout << "Data sent via pipe.\n" << std::endl;

    // Clean up
    WaitForSingleObject(hThread, INFINITE);
    VirtualFreeEx(hProcess, pRemoteMemory, 0, MEM_RELEASE);
    CloseHandle(hThread);
    CloseHandle(hProcess);

    std::cout << "Clean up successful." << std::endl;

    return true;
}

// Helper function to convert char* to LPCWSTR (wide string)
LPCWSTR ConvertToLPCWSTR(const char* charArray) {
    int wcharCount = MultiByteToWideChar(CP_UTF8, 0, charArray, -1, NULL, 0);
    wchar_t* wString = new wchar_t[wcharCount];
    MultiByteToWideChar(CP_UTF8, 0, charArray, -1, wString, wcharCount);
    return wString;
}

BOOL CreateProcessWithInjectedDLL(LPCWSTR programName, const char * logFileName) {

    // Create process in suspended mode
    STARTUPINFO si = { sizeof(si) };
    PROCESS_INFORMATION pi;
    if (!CreateProcess(programName, NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) {
		std::cerr << "Error: CreateProcess failed." << std::endl;
		return FALSE;
	}

    // Open Pipe
    HANDLE hPipe = OpenPipe();
    // Open named pipe for communication with the DLL
    if (hPipe == NULL) {
        throw std::runtime_error("Error: Failed to open pipe.");
    }


    // Inject the DLL into the target process
    if (!InjectDLL(pi.dwProcessId, DLL_PATH, hPipe,logFileName)) {
		std::cerr << "Error: Failed to inject DLL into target process." << std::endl;
		TerminateProcess(pi.hProcess, 0);
		return FALSE;
	}


    std::cout << "Resuming Process: \n-----------------------------------\n" << std::endl;
	// Resume the target process
	ResumeThread(pi.hThread);


	// Wait for the process to exit
	WaitForSingleObject(pi.hProcess, INFINITE);

	// Close process and thread handles
	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);

    std::cout << "Process exited successfully." << std::endl;

	return TRUE;
}

int main(int argc, char* argv[]) {
    ParsedArgs args = parseArguments(argc, argv);

    std::cout << "Program to check: " << args.programToCheck << std::endl;
    std::cout << "Log file: " << args.logFile << std::endl;

    // convert program name to LPCWSTR
    LPCWSTR programName = ConvertToLPCWSTR(args.programToCheck.c_str());

    // Create process with injected DLL
    if (!CreateProcessWithInjectedDLL(programName, args.logFile.c_str())) {
		std::cerr << "Error: Failed to create process with injected DLL." << std::endl;
		return 1;
	}

    delete programName;


    return 0;
}

