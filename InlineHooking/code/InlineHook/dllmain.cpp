// dllmain.cpp : Defines the entry point for the DLL application.
#include "pch.h"
#include <windows.h>
#include <iostream>
#include <iomanip>


// Define the function pointer type using typedef for MessageBoxW
//typedef int(__stdcall* tdOrigMessageBoxW)(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);
using PrototypeMessageBoxW = int (WINAPI*)(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);

// Declare a variable as a function pointer of the defined type
//tdOrigMessageBoxW messageBoxWTrampoline = NULL;
PrototypeMessageBoxW messageBoxWTrampoline = nullptr;

// Define the function pointer type using typedef for OutputDebugStringW
typedef void(__stdcall* tdOrigOutputDebugStringW)(LPCWSTR lpOutputString);
// Declare a variable as a function pointer of the defined type
tdOrigOutputDebugStringW outputDebugStringWTrampoline = NULL;

// Declare a variable for file for writing
LPCWSTR filePathFromInjector = NULL;


BOOL WriteToFile(LPCWSTR str, LPCWSTR filePath) {
    // Open the file with write access, append to the end, and create the file if it doesn't exist
    HANDLE hFile = CreateFileW(filePath,
        FILE_APPEND_DATA,
        FILE_SHARE_READ,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        // Failed to open or create the file
        return FALSE;
    }

    DWORD bytesWritten;
    BOOL result = WriteFile(hFile,           // Handle to the file
        str,             // Buffer to write from
        wcslen(str) * sizeof(wchar_t),  // Number of bytes to write
        &bytesWritten,   // Number of bytes that were written
        NULL);           // No overlapping structure

    // Write the newline if the string was written successfully
    if (result) {
        LPCWSTR newline = L"\r\n";
        WriteFile(hFile, newline, wcslen(newline) * sizeof(wchar_t), &bytesWritten, NULL);
    }

    // Close the file handle
    CloseHandle(hFile);

    return result;
}


// Define the hook function for MessageBoxW
int __stdcall DetourMessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType) {
	
    /*std::cout << "HOLAAAA FROM HOOKKKK!!!!!!" << std::endl;
    std::cout << "messageBoxWTrampoline: " << (void*)messageBoxWTrampoline << std::endl;*/

    // Write the message box text and caption to the file
    WriteToFile(lpText, filePathFromInjector);
    WriteToFile(lpCaption, filePathFromInjector);

    // Call the original MessageBoxW function using the trampoline
	return messageBoxWTrampoline(hWnd, lpText, lpCaption, uType);
}


// Define the hook function for OutputDebugStringW
void __stdcall DetourOutputDebugStringW(LPCWSTR lpOutputString) {
    /*std::cout << "HOLAAAA FROM HOOKKKK!!!!!!" << std::endl;
	std::cout << "outputDebugStringWTrampoline: " << (void*)outputDebugStringWTrampoline << std::endl;*/

    // Write the output string to the file
    WriteToFile(lpOutputString, filePathFromInjector);

	// Call the original OutputDebugStringW function using the trampoline
	return outputDebugStringWTrampoline(lpOutputString);
}


// Function to parse the input string
char* parseToken(const char*& input, char delimiter) {
    int length = 0;
    while (input[length] != delimiter && input[length] != '\0') {
        length++;
    }

    char* token = new char[length + 1];
    for (int i = 0; i < length; ++i) {
        token[i] = input[i];
    }
    token[length] = '\0';

    input += length + 1; // move input pointer to next token
    return token;
}

// Function to parse the filename from the input string
char* parseFilename(const char*& input) {
    return parseToken(input, '|');
}

// Function to parse the flag from the input string
int parseFlag(const char*& input) {
    char* token = parseToken(input, '|');
    int flag = (token[0] == 'T' || token[0] == 't') ? 1 : 0;
    delete[] token;
    return flag;
}


// Function to allocate a page near a target address for the relay function
void* AllocatePageNearAddress(void* targetAddr)
{
    SYSTEM_INFO sysInfo;
    GetSystemInfo(&sysInfo);
    const uint64_t PAGE_SIZE = sysInfo.dwPageSize;

    uint64_t startAddr = (uint64_t(targetAddr) & ~(PAGE_SIZE - 1)); //round down to nearest page boundary
    uint64_t minAddr = min(startAddr - 0x7FFFFF00, (uint64_t)sysInfo.lpMinimumApplicationAddress);
    uint64_t maxAddr = max(startAddr + 0x7FFFFF00, (uint64_t)sysInfo.lpMaximumApplicationAddress);

    uint64_t startPage = (startAddr - (startAddr % PAGE_SIZE));

    uint64_t pageOffset = 1;
    while (1)
    {
        uint64_t byteOffset = pageOffset * PAGE_SIZE;
        uint64_t highAddr = startPage + byteOffset;
        uint64_t lowAddr = (startPage > byteOffset) ? startPage - byteOffset : 0;

        bool needsExit = highAddr > maxAddr && lowAddr < minAddr;

        if (highAddr < maxAddr)
        {
            void* outAddr = VirtualAlloc((void*)highAddr, PAGE_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
            if (outAddr)
                return outAddr;
        }

        if (lowAddr > minAddr)
        {
            void* outAddr = VirtualAlloc((void*)lowAddr, PAGE_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
            if (outAddr != nullptr)
                return outAddr;
        }

        pageOffset++;

        if (needsExit)
        {
            break;
        }
    }

    return nullptr;
}

// Function to write an absolute jump instruction to a memory location
void WriteAbsoluteJump64(void* absJumpMemory, void* addrToJumpTo)
{
    uint8_t absJumpInstructions[] =
    {
      0x49, 0xBA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //mov r10, addr
      0x41, 0xFF, 0xE2 //jmp r10
    };

    uint64_t addrToJumpTo64 = (uint64_t)addrToJumpTo;
    memcpy(&absJumpInstructions[2], &addrToJumpTo64, sizeof(addrToJumpTo64));
    memcpy(absJumpMemory, absJumpInstructions, sizeof(absJumpInstructions));
}

void InstallHook(void* func2hook, void* payloadFunction)
{
    void* relayFuncMemory = AllocatePageNearAddress(func2hook);
    WriteAbsoluteJump64(relayFuncMemory, payloadFunction); //write relay func instructions

    //now that the relay function is built, we need to install the E9 jump into the target func,
    //this will jump to the relay function
    DWORD oldProtect;
    VirtualProtect(func2hook, 1024, PAGE_EXECUTE_READWRITE, &oldProtect);

    //32 bit relative jump opcode is E9, takes 1 32 bit operand for jump offset
    uint8_t jmpInstruction[5] = { 0xE9, 0x0, 0x0, 0x0, 0x0 };

    //to fill out the last 4 bytes of jmpInstruction, we need the offset between 
    //the relay function and the instruction immediately AFTER the jmp instruction
    const uint64_t relAddr = (uint64_t)relayFuncMemory - ((uint64_t)func2hook + sizeof(jmpInstruction));
    memcpy(jmpInstruction + 1, &relAddr, 4);

    //install the hook
    memcpy(func2hook, jmpInstruction, sizeof(jmpInstruction));
}

// Function to print the bytes of a memory region (Debugging purposes)
void PrintMemoryBytes(const void* address, size_t numBytes) {
    // Cast the address to a byte pointer for byte-by-byte access.
    const unsigned char* bytes = static_cast<const unsigned char*>(address);

    std::cout << "Memory at address " << address << ":\n";
    std::cout << std::hex << std::setfill('0');  // Print in hexadecimal format

    for (size_t i = 0; i < numBytes; ++i) {
        std::cout << std::setw(2) << (unsigned int)bytes[i] << " ";
        if ((i + 1) % 8 == 0)  // New line every 8 bytes for better readability
            std::cout << "\n";
    }

    std::cout << std::dec << "\n";  // Switch back to decimal output
}


BYTE* CreateTrampoline(void* originalFunction) {

    //std::cout << "----------------- Trampoline -----------------" << std::endl;
    //PrintMemoryBytes(trampolineAddress, 32);

    BYTE* origFunctionAddress = NULL;
    BYTE* trampolineAddress = NULL;

    origFunctionAddress = (BYTE*)originalFunction;

    //std::cout << "Address of " << functionName << " is " << (void*)origFunctionAddress << std::endl;

    // Allocate some memory to store our trampoline
    trampolineAddress = (BYTE*)VirtualAlloc(NULL, 60, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (trampolineAddress == NULL) {
        return NULL;
    }

    //std::cout << "Trampoline address is " << (void*) trampolineAddress << std::endl;

    int numOfBytesToCopy = 7;
    char trampoline[30] = {};

    // Copy bytes from the original function to our trampoline
    errno_t num = memcpy_s(trampoline, numOfBytesToCopy, origFunctionAddress, 7);

    if(num)
        std::cout << "Error copying bytes" << std::endl;

    // At the the end of the copied bytes we want to JMP back to the original function
    *(DWORD*)(trampoline + numOfBytesToCopy) = 0x48;
    *(DWORD*)(trampoline + numOfBytesToCopy + 1) = 0xB8; // MOV RAX, <origFunctionAddress>
    *((uint64_t*)(trampoline + numOfBytesToCopy + 2)) = (uint64_t)origFunctionAddress + numOfBytesToCopy; // +7 to skip the copied bytes
    *(DWORD*)(trampoline + numOfBytesToCopy + 10) = 0xFF;
    *(DWORD*)(trampoline + numOfBytesToCopy + 11) = 0xE0; // JMP RAX
    
    // Write the trampoline to the allocated trampoline memory region
    if (!WriteProcessMemory(GetCurrentProcess(), trampolineAddress, trampoline, sizeof(trampoline), NULL)) {
        return NULL;
    }
    //PrintMemoryBytes(trampolineAddress, 32);
    return trampolineAddress;
}

BOOL HookMessageBoxW() {
    void* originalMessageBoxW = GetProcAddress(GetModuleHandleA("user32.dll"), "MessageBoxW");

    void* trampolineAddress = CreateTrampoline(originalMessageBoxW);
    if (trampolineAddress == NULL) {
		return FALSE;
	}

    // Save the trampoline address to call the original function
    messageBoxWTrampoline = (PrototypeMessageBoxW)trampolineAddress;

    InstallHook(originalMessageBoxW, (void*)DetourMessageBoxW);

    return TRUE;
}

// Function to calculate the absolute jump address
uint64_t CalculateJumpAddress(uint64_t IA, uint64_t offset, uint64_t relative_address) {
    // Calculate the next instruction address
    uint64_t NI = IA + offset;
    // Calculate the target address by adding the relative address to NI
    uint64_t target = NI + relative_address;
    return target;
}

uint32_t ExtractRelativeAddress(void* address) {
    uint8_t* addressBytes = (uint8_t*)address;
    // Read 4 bytes as little-endian integer
    if (addressBytes[0] == 0x48 && addressBytes[1] == 0xFF && addressBytes[2] == 0x25) {
        return addressBytes[0] | (addressBytes[1] << 8) | (addressBytes[2] << 16) | (addressBytes[3] << 24);
    }
    return 0;
}

// Function to extract the absolute jump address using RIP-relative addressing
uint64_t calculateAbsoluteAddress(void* IA) {
    // Cast the instruction address to a byte pointer
    const uint8_t* bytes = reinterpret_cast<const uint8_t*>(IA);

    // Verify the expected opcode sequence for the jump instruction: 48 FF 25
    if (bytes[0] == 0x48 && bytes[1] == 0xFF && bytes[2] == 0x25) {
        // Calculate the address of the next instruction, which is the current address + size of the instruction (7 bytes)
        uint64_t nextInstructionAddress = reinterpret_cast<uint64_t>(IA) + 7;

        // Extract the 32-bit displacement (signed) from the opcode sequence
        int32_t displacement = *reinterpret_cast<const int32_t*>(bytes + 3);

        // Calculate and return the absolute address
        return nextInstructionAddress + displacement;
    }
    else {
        // If the opcode sequence does not match, return an error indication (0 typically means an error in pointer contexts)
        MessageBoxA(NULL, "Unexpected opcode sequence!", "Error", MB_OK | MB_ICONERROR);
        return 0;
    }
}

BOOL HookOutputDebugStringW() {
    void* originalOutputDebugStringW = GetProcAddress(GetModuleHandleA("KernelBase.dll"), "OutputDebugStringW");

    void* trampolineAddress = (BYTE*)VirtualAlloc(NULL, 60, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    // Copy bytes from the original function to our trampoline
    int numOfBytesToCopy = 7;
    char trampoline[30] = {};
    memcpy_s(trampoline, numOfBytesToCopy, originalOutputDebugStringW, 7);
    if (!WriteProcessMemory(GetCurrentProcess(), trampolineAddress, trampoline, sizeof(trampoline), NULL)) {
        return NULL;
    }

    // Add jump at byte 7 to jump back to the original function (r10 register)
    WriteAbsoluteJump64((void*)((uint64_t)trampolineAddress + 7), (void*)((uint64_t)originalOutputDebugStringW + 7)); 

    // Save the trampoline address to call the original function
    outputDebugStringWTrampoline = (tdOrigOutputDebugStringW)trampolineAddress;

    InstallHook(originalOutputDebugStringW, (void*)DetourOutputDebugStringW);

    return TRUE;
}

// Helper function to convert char* to LPCWSTR (wide string)
LPCWSTR ConvertToLPCWSTR(const char* charArray) {
    int wcharCount = MultiByteToWideChar(CP_UTF8, 0, charArray, -1, NULL, 0);
    wchar_t* wString = new wchar_t[wcharCount];
    MultiByteToWideChar(CP_UTF8, 0, charArray, -1, wString, wcharCount);
    return wString;
}

// Create a named pipe server to receive the input from the injector
BOOL GetCommandInjectorAndHook() {
    HANDLE hPipe = CreateFileW(
        L"\\\\.\\pipe\\MyPipe",
        GENERIC_READ,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (hPipe == INVALID_HANDLE_VALUE) {
        MessageBoxW(NULL, L"Failed to connect to the named pipe.", L"Error", MB_OK);
        return FALSE;
    }

    char buffer[1024];
    DWORD bytesRead;
    if (ReadFile(hPipe, buffer, sizeof(buffer), &bytesRead, NULL) && bytesRead > 0) {
        buffer[bytesRead] = '\0'; // Ensure null-termination
    }
    else {
        MessageBoxW(NULL, L"Failed to read from the named pipe.", L"Error", MB_OK);
    }
    CloseHandle(hPipe);

    // Parse the buffer
    const char* input = buffer;
    char* filename = parseFilename(input);
    filePathFromInjector = ConvertToLPCWSTR(filename);
    int mFlag = parseFlag(input);
    int oFlag = parseFlag(input);

    if (mFlag == 1) {
        HookMessageBoxW();
        //std::cout << "Hooked MessageBoxW Finished" << std::endl;
    }

    if (oFlag == 1) {
        HookOutputDebugStringW();
        //std::cout << "Hooked OutputDebugStringW Finished" << std::endl;
    }

    //std::cout << "END OF DLL" << std::endl;
    return TRUE;
}

BOOL APIENTRY DllMain(HMODULE hModule,
    DWORD  ul_reason_for_call,
    LPVOID lpReserved
)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
    {
        GetCommandInjectorAndHook();
        break;
    }
    case DLL_THREAD_ATTACH:
        break;
    case DLL_THREAD_DETACH:
        break;
    case DLL_PROCESS_DETACH:
        delete[] filePathFromInjector;
        break;
    }
    return TRUE;
}
