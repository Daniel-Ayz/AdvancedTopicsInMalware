#include <iostream>
#include <string>
#include <vector>
#include <windows.h>
#include <tlhelp32.h>
#include <sstream>

struct CommandLineOptions {
    std::string executableName;
    std::string outputFileName;
    bool mFlag = false; // MessageBoxW hooking
    bool oFlag = false; // OutputDebugStringW hooking
};

CommandLineOptions parseCommandLine(int argc, char* argv[]) {
    CommandLineOptions options;

    if (argc < 4) { // Ensure minimum arguments: executable, one filename, and one flag
        throw std::runtime_error("Usage: Detour-ex1.exe <program.exe> <filename> [-m] [-o]");
    }

    // First argument after the program name is the executable to detour
    options.executableName = argv[1];

    // Initialize flags to determine if filename is set
    bool filenameSet = false;

    // Parse remaining arguments for flags or filename
    for (int i = 2; i < argc; ++i) {
        std::string arg = argv[i];
        if (arg == "-m") {
            options.mFlag = true;
        }
        else if (arg == "-o") {
            options.oFlag = true;
        }
        else if (!filenameSet) { // Assume the first non-flag argument after the executable is the filename
            options.outputFileName = arg;
            filenameSet = true;
        }
        else {
            throw std::runtime_error("Unexpected argument or filename already set: " + arg);
        }
    }

    // Check if the filename and at least one flag is set
    if (!filenameSet) {
        throw std::runtime_error("Filename is required.");
    }
    if (!options.mFlag && !options.oFlag) {
        throw std::runtime_error("At least one flag (-m or -o) is required.");
    }

    return options;
}

std::vector<DWORD> FindProcessId(const std::string& processName) {
    std::vector<DWORD> processIds;
    PROCESSENTRY32 processInfo;
    processInfo.dwSize = sizeof(processInfo);

    HANDLE processesSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
    if (processesSnapshot == INVALID_HANDLE_VALUE) {
        return processIds;
    }

    Process32First(processesSnapshot, &processInfo);
    if (!processName.compare(processInfo.szExeFile)) {
        processIds.push_back(processInfo.th32ProcessID);
    }

    while (Process32Next(processesSnapshot, &processInfo)) {
        if (!processName.compare(processInfo.szExeFile)) {
            processIds.push_back(processInfo.th32ProcessID);
        }
    }

    CloseHandle(processesSnapshot);
    return processIds;
}

bool InjectDLL(DWORD pid, const char* dllPath) {
    // 1. Retrieve the address of LoadLibraryA from the current process
    HMODULE hKernel32 = GetModuleHandle("Kernel32");
    FARPROC pLoadLibraryA = GetProcAddress(hKernel32, "LoadLibraryA");
    if (pLoadLibraryA == NULL) {
        std::cerr << "Error: Could not find LoadLibraryA function address.\n";
        return false;
    }

    // 2. Open the target process, allocate memory, and write the DLL path to it
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (hProcess == NULL) {
        std::cerr << "Error: Could not open target process.\n";
        return false;
    }

    LPVOID pRemoteMemory = VirtualAllocEx(hProcess, NULL, strlen(dllPath) + 1, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE);
    if (pRemoteMemory == NULL) {
        std::cerr << "Error: Could not allocate memory in target process.\n";
        CloseHandle(hProcess);
        return false;
    }

    if (!WriteProcessMemory(hProcess, pRemoteMemory, (void*)dllPath, strlen(dllPath) + 1, NULL)) {
        std::cerr << "Error: Could not write to process memory.\n";
        VirtualFreeEx(hProcess, pRemoteMemory, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return false;
    }

    // 3. Create a remote thread to load the DLL
    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pLoadLibraryA, pRemoteMemory, 0, NULL);
    if (hThread == NULL) {
        std::cerr << "Error: Could not create remote thread.\n";
        VirtualFreeEx(hProcess, pRemoteMemory, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return false;
    }

    std::cout << "DLL injection successful.\n";

    // Cleanup code (Wait for the remote thread to finish, free memory, and close handles) -> won't work if the dll is waiting for a named pipe!
    
    //// Wait for the remote thread to finish
    //WaitForSingleObject(hThread, INFINITE);

    //// Cleanup
    //VirtualFreeEx(hProcess, pRemoteMemory, 0, MEM_RELEASE);
    //CloseHandle(hThread);
    //CloseHandle(hProcess);

    //std::cout << "Cleanup successful.\n";
    return true;
}

std::string unparseString(const std::string& message, bool flag1, bool flag2) {
    std::ostringstream oss;
    oss << message << "|" << (flag1 ? "True" : "False") << "|" << (flag2 ? "True" : "False");
    return oss.str();
}

//Function to open named pipe for communication with the DLL
HANDLE OpenPipe() {
    HANDLE hPipe;
    LPCWSTR pipeName = L"\\\\.\\pipe\\MyPipe";

    // Create a named pipe
    hPipe = CreateNamedPipeW(
        pipeName,
        PIPE_ACCESS_OUTBOUND,
        PIPE_TYPE_BYTE | PIPE_WAIT,
        1,
        0,
        0,
        0,
        NULL);

    if (hPipe == INVALID_HANDLE_VALUE) {
        std::cerr << "CreateNamedPipe failed: " << GetLastError() << std::endl;
        return NULL;
    }

    return hPipe;
}

// Function to send data via named pipe to the DLL
BOOL SendDataViaPipe(HANDLE hPipe, const char* data) {
    std::cout << "Waiting for DLL to connect..." << std::endl;

    // Wait for a client to connect
    if (!ConnectNamedPipe(hPipe, NULL)) {
        std::cerr << "ConnectNamedPipe failed: " << GetLastError() << std::endl;
        CloseHandle(hPipe);
        return 1;
    }

    std::cout << "Sending data..." << std::endl;

    // Send data
    //const char* data = "Hello from injector!|True|False";
    DWORD bytesWritten;
    if (!WriteFile(hPipe, data, strlen(data) + 1, &bytesWritten, NULL)) {
        std::cerr << "WriteFile failed: " << GetLastError() << std::endl;
        CloseHandle(hPipe);
        return 1;
    }

    // Close the pipe
    CloseHandle(hPipe);
    return 0;
}


int main(int argc, char* argv[]) {
    const char* dllPath = "C:\\Users\\user\\source\\repos\\InlineHooking\\x64\\Debug\\InlineHook.dll";

    try {
        // Parse command line arguments
        CommandLineOptions options = parseCommandLine(argc, argv);
        std::cout << "Executable to detour: " << options.executableName << std::endl;
        std::cout << "Output file name: " << options.outputFileName << std::endl;
        std::cout << "Flag -m is " << (options.mFlag ? "set" : "not set") << std::endl;
        std::cout << "Flag -o is " << (options.oFlag ? "set" : "not set") << std::endl;

        // Parse the message and flags into a single string
        // Format: message|flag1|flag2 
        // -> in our case it will be: outputFileName|mFlag|oFlag
        std::string data = unparseString(options.outputFileName, options.mFlag, options.oFlag);
        std::cout << "Data to send: " << data << std::endl;

        HANDLE hPipe = OpenPipe();
        // Open named pipe for communication with the DLL
        if (hPipe == NULL) {
			throw std::runtime_error("Error: Failed to open pipe.");
		}
        std::cout << "Pipe opened successfully. pipe handle: " << hPipe << std::endl;

        // Find the process ID of the target executable
        std::vector<DWORD> processIds = FindProcessId(options.executableName);
        if (processIds.empty()) {
			throw std::runtime_error("Error: Could not find process ID for " + options.executableName);
		}
        std::cout << "Process ID: " << processIds[0] << std::endl;

        // Inject the DLL into the target process
        if (!InjectDLL(processIds[0], dllPath)) {
            throw std::runtime_error("Error: Failed to inject MessageBoxHook.dll");
        }

        // Send data via named pipe to the DLL
        if (SendDataViaPipe(hPipe, data.c_str())) {
            throw std::runtime_error("Error: Failed to send data via pipe.");
        }
    }
    catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
    return 0;
}
