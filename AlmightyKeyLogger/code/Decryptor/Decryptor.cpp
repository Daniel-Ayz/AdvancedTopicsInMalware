#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <filesystem>

// Function to pad the input to a multiple of the key length
std::string padString(const std::string& input, size_t blockSize) {
    std::string padded = input;
    size_t paddingNeeded = blockSize - (input.size() % blockSize);
    padded.append(paddingNeeded, '\0'); // Padding with null characters
    return padded;
}

// Function to strip the padding from the decrypted string
std::string stripPadding(const std::string& input) {
    size_t end = input.find_last_not_of('\0');
    return (end == std::string::npos) ? "" : input.substr(0, end + 1);
}

// Updated encryption/decryption function with padding
std::string xorEncryptDecrypt(const std::string& input, const std::string& key, bool encrypt = true) {
    std::string processed = encrypt ? padString(input, key.length()) : input;
    std::string output = processed;

    for (size_t i = 0; i < processed.size(); ++i) {
        output[i] = processed[i] ^ key[i % key.length()];
    }

    return encrypt ? output : stripPadding(output);
}

// Function to decrypt the log file and return its content
std::string decryptLogFile(const std::string& encryptedFilePath, const std::string& key) {
    std::ifstream inFile(encryptedFilePath, std::ios::in | std::ios::binary);
    if (inFile.is_open()) {
        std::stringstream buffer;
        buffer << inFile.rdbuf();
        inFile.close();
        std::string fileContent = buffer.str();

        std::string decryptedContent;
        size_t keyLength = key.length();
        for (size_t i = 0; i < fileContent.size(); i += keyLength) {
            std::string encryptedEntry = fileContent.substr(i, keyLength);
            std::string decryptedEntry = xorEncryptDecrypt(encryptedEntry, key, false);
            decryptedContent += decryptedEntry; // Append decrypted entry to content
        }
        return decryptedContent;
    }
    else {
        std::cerr << "Failed to open file for reading: " << encryptedFilePath << std::endl;
        return "";
    }
}

int main(int argc, char* argv[]) {
    if (argc < 4) {
        std::cerr << "Usage: " << argv[0] << " <directory_path> <key> <merged_decrypted_output_file_path>" << std::endl;
        return 1;
    }

    std::string directoryPath = argv[1];
    std::string key = argv[2];
    std::string decryptedFilePath = argv[3];

    std::ofstream outFile(decryptedFilePath, std::ios::out | std::ios::binary);
    if (!outFile.is_open()) {
        std::cerr << "Failed to open file for writing: " << decryptedFilePath << std::endl;
        return 1;
    }

    for (const auto& entry : std::filesystem::directory_iterator(directoryPath)) {
        if (entry.is_regular_file()) {
            std::string filePath = entry.path().string();
            if (filePath.find("Session") != std::string::npos && filePath.find(".log") != std::string::npos) {
                std::string decryptedContent = decryptLogFile(filePath, key);
                outFile << decryptedContent; // Write decrypted content to merged file
            }
        }
    }

    outFile.close();
    std::cout << "Decryption complete. Merged decrypted file created at: " << decryptedFilePath << std::endl;

    return 0;
}
